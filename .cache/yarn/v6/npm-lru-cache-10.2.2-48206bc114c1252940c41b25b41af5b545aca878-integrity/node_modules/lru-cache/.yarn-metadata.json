{
  "manifest": {
    "name": "lru-cache",
    "description": "A cache object that deletes the least-recently-used items.",
    "version": "10.2.2",
    "author": {
      "name": "Isaac Z. Schlueter",
      "email": "i@izs.me"
    },
    "keywords": [
      "mru",
      "lru",
      "cache"
    ],
    "sideEffects": false,
    "scripts": {
      "build": "npm run prepare",
      "prepare": "tshy && bash fixup.sh",
      "pretest": "npm run prepare",
      "presnap": "npm run prepare",
      "test": "tap",
      "snap": "tap",
      "preversion": "npm test",
      "postversion": "npm publish",
      "prepublishOnly": "git push origin --follow-tags",
      "format": "prettier --write .",
      "typedoc": "typedoc --tsconfig ./.tshy/esm.json ./src/*.ts",
      "benchmark-results-typedoc": "bash scripts/benchmark-results-typedoc.sh",
      "prebenchmark": "npm run prepare",
      "benchmark": "make -C benchmark",
      "preprofile": "npm run prepare",
      "profile": "make -C benchmark profile"
    },
    "main": "./dist/commonjs/index.js",
    "types": "./dist/commonjs/index.d.ts",
    "tshy": {
      "exports": {
        ".": "./src/index.ts",
        "./min": {
          "import": {
            "types": "./dist/esm/index.d.ts",
            "default": "./dist/esm/index.min.js"
          },
          "require": {
            "types": "./dist/commonjs/index.d.ts",
            "default": "./dist/commonjs/index.min.js"
          }
        }
      }
    },
    "repository": {
      "type": "git",
      "url": "git://github.com/isaacs/node-lru-cache.git"
    },
    "devDependencies": {
      "@tapjs/clock": "^1.1.16",
      "@types/node": "^20.2.5",
      "@types/tap": "^15.0.6",
      "benchmark": "^2.1.4",
      "clock-mock": "^2.0.2",
      "esbuild": "^0.17.11",
      "eslint-config-prettier": "^8.5.0",
      "marked": "^4.2.12",
      "mkdirp": "^2.1.5",
      "prettier": "^2.6.2",
      "tap": "^18.5.7",
      "tshy": "^1.8.0",
      "tslib": "^2.4.0",
      "typedoc": "^0.25.3",
      "typescript": "^5.2.2"
    },
    "license": "ISC",
    "files": [
      "dist"
    ],
    "engines": {
      "node": "14 || >=16.14"
    },
    "prettier": {
      "semi": false,
      "printWidth": 70,
      "tabWidth": 2,
      "useTabs": false,
      "singleQuote": true,
      "jsxSingleQuote": false,
      "bracketSameLine": true,
      "arrowParens": "avoid",
      "endOfLine": "lf"
    },
    "tap": {
      "node-arg": [
        "--expose-gc"
      ],
      "plugin": [
        "@tapjs/clock"
      ]
    },
    "exports": {
      ".": {
        "import": {
          "types": "./dist/esm/index.d.ts",
          "default": "./dist/esm/index.js"
        },
        "require": {
          "types": "./dist/commonjs/index.d.ts",
          "default": "./dist/commonjs/index.js"
        }
      },
      "./min": {
        "import": {
          "types": "./dist/esm/index.d.ts",
          "default": "./dist/esm/index.min.js"
        },
        "require": {
          "types": "./dist/commonjs/index.d.ts",
          "default": "./dist/commonjs/index.min.js"
        }
      }
    },
    "type": "module",
    "_registry": "npm",
    "_loc": "/home/dpcsdev/.cache/yarn/v6/npm-lru-cache-10.2.2-48206bc114c1252940c41b25b41af5b545aca878-integrity/node_modules/lru-cache/package.json",
    "readmeFilename": "README.md",
    "readme": "# lru-cache\n\nA cache object that deletes the least-recently-used items.\n\nSpecify a max number of the most recently used items that you\nwant to keep, and this cache will keep that many of the most\nrecently accessed items.\n\nThis is not primarily a TTL cache, and does not make strong TTL\nguarantees. There is no preemptive pruning of expired items by\ndefault, but you _may_ set a TTL on the cache or on a single\n`set`. If you do so, it will treat expired items as missing, and\ndelete them when fetched. If you are more interested in TTL\ncaching than LRU caching, check out\n[@isaacs/ttlcache](http://npm.im/@isaacs/ttlcache).\n\nAs of version 7, this is one of the most performant LRU\nimplementations available in JavaScript, and supports a wide\ndiversity of use cases. However, note that using some of the\nfeatures will necessarily impact performance, by causing the\ncache to have to do more work. See the \"Performance\" section\nbelow.\n\n## Installation\n\n```bash\nnpm install lru-cache --save\n```\n\n## Usage\n\n```js\n// hybrid module, either works\nimport { LRUCache } from 'lru-cache'\n// or:\nconst { LRUCache } = require('lru-cache')\n// or in minified form for web browsers:\nimport { LRUCache } from 'http://unpkg.com/lru-cache@9/dist/mjs/index.min.mjs'\n\n// At least one of 'max', 'ttl', or 'maxSize' is required, to prevent\n// unsafe unbounded storage.\n//\n// In most cases, it's best to specify a max for performance, so all\n// the required memory allocation is done up-front.\n//\n// All the other options are optional, see the sections below for\n// documentation on what each one does.  Most of them can be\n// overridden for specific items in get()/set()\nconst options = {\n  max: 500,\n\n  // for use with tracking overall storage size\n  maxSize: 5000,\n  sizeCalculation: (value, key) => {\n    return 1\n  },\n\n  // for use when you need to clean up something when objects\n  // are evicted from the cache\n  dispose: (value, key) => {\n    freeFromMemoryOrWhatever(value)\n  },\n\n  // how long to live in ms\n  ttl: 1000 * 60 * 5,\n\n  // return stale items before removing from cache?\n  allowStale: false,\n\n  updateAgeOnGet: false,\n  updateAgeOnHas: false,\n\n  // async method to use for cache.fetch(), for\n  // stale-while-revalidate type of behavior\n  fetchMethod: async (\n    key,\n    staleValue,\n    { options, signal, context }\n  ) => {},\n}\n\nconst cache = new LRUCache(options)\n\ncache.set('key', 'value')\ncache.get('key') // \"value\"\n\n// non-string keys ARE fully supported\n// but note that it must be THE SAME object, not\n// just a JSON-equivalent object.\nvar someObject = { a: 1 }\ncache.set(someObject, 'a value')\n// Object keys are not toString()-ed\ncache.set('[object Object]', 'a different value')\nassert.equal(cache.get(someObject), 'a value')\n// A similar object with same keys/values won't work,\n// because it's a different object identity\nassert.equal(cache.get({ a: 1 }), undefined)\n\ncache.clear() // empty the cache\n```\n\nIf you put more stuff in the cache, then less recently used items\nwill fall out. That's what an LRU cache is.\n\n## `class LRUCache<K, V, FC = unknown>(options)`\n\nCreate a new `LRUCache` object.\n\nWhen using TypeScript, set the `K` and `V` types to the `key` and\n`value` types, respectively.\n\nThe `FC` (\"fetch context\") generic type defaults to `unknown`.\nIf set to a value other than `void` or `undefined`, then any\ncalls to `cache.fetch()` _must_ provide a `context` option\nmatching the `FC` type. If `FC` is set to `void` or `undefined`,\nthen `cache.fetch()` _must not_ provide a `context` option. See\nthe documentation on `async fetch()` below.\n\n## Options\n\nAll options are available on the LRUCache instance, making it\nsafe to pass an LRUCache instance as the options argument to make\nanother empty cache of the same type.\n\nSome options are marked read-only because changing them after\ninstantiation is not safe. Changing any of the other options\nwill of course only have an effect on subsequent method calls.\n\n### `max` (read only)\n\nThe maximum number of items that remain in the cache (assuming no\nTTL pruning or explicit deletions). Note that fewer items may be\nstored if size calculation is used, and `maxSize` is exceeded.\nThis must be a positive finite intger.\n\nAt least one of `max`, `maxSize`, or `TTL` is required. This\nmust be a positive integer if set.\n\n**It is strongly recommended to set a `max` to prevent unbounded\ngrowth of the cache.** See \"Storage Bounds Safety\" below.\n\n### `maxSize` (read only)\n\nSet to a positive integer to track the sizes of items added to\nthe cache, and automatically evict items in order to stay below\nthis size. Note that this may result in fewer than `max` items\nbeing stored.\n\nAttempting to add an item to the cache whose calculated size is\ngreater that this amount will be a no-op. The item will not be\ncached, and no other items will be evicted.\n\nOptional, must be a positive integer if provided.\n\nSets `maxEntrySize` to the same value, unless a different value\nis provided for `maxEntrySize`.\n\nAt least one of `max`, `maxSize`, or `TTL` is required. This\nmust be a positive integer if set.\n\nEven if size tracking is enabled, **it is strongly recommended to\nset a `max` to prevent unbounded growth of the cache.** See\n\"Storage Bounds Safety\" below.\n\n### `maxEntrySize`\n\nSet to a positive integer to track the sizes of items added to\nthe cache, and prevent caching any item over a given size.\nAttempting to add an item whose calculated size is greater than\nthis amount will be a no-op. The item will not be cached, and no\nother items will be evicted.\n\nOptional, must be a positive integer if provided. Defaults to\nthe value of `maxSize` if provided.\n\n### `sizeCalculation`\n\nFunction used to calculate the size of stored items. If you're\nstoring strings or buffers, then you probably want to do\nsomething like `n => n.length`. The item is passed as the first\nargument, and the key is passed as the second argument.\n\nThis may be overridden by passing an options object to\n`cache.set()`.\n\nRequires `maxSize` to be set.\n\nIf the `size` (or return value of `sizeCalculation`) for a given\nentry is greater than `maxEntrySize`, then the item will not be\nadded to the cache.\n\n### `fetchMethod` (read only)\n\nFunction that is used to make background asynchronous fetches.\nCalled with `fetchMethod(key, staleValue, { signal, options,\ncontext })`. May return a Promise.\n\nIf `fetchMethod` is not provided, then `cache.fetch(key)` is\nequivalent to `Promise.resolve(cache.get(key))`.\n\nIf at any time, `signal.aborted` is set to `true`, or if the\n`signal.onabort` method is called, or if it emits an `'abort'`\nevent which you can listen to with `addEventListener`, then that\nmeans that the fetch should be abandoned. This may be passed\nalong to async functions aware of AbortController/AbortSignal\nbehavior.\n\nThe `fetchMethod` should **only** return `undefined` or a Promise\nresolving to `undefined` if the AbortController signaled an\n`abort` event. In all other cases, it should return or resolve\nto a value suitable for adding to the cache.\n\nThe `options` object is a union of the options that may be\nprovided to `set()` and `get()`. If they are modified, then that\nwill result in modifying the settings to `cache.set()` when the\nvalue is resolved, and in the case of `noDeleteOnFetchRejection`\nand `allowStaleOnFetchRejection`, the handling of `fetchMethod`\nfailures.\n\nFor example, a DNS cache may update the TTL based on the value\nreturned from a remote DNS server by changing `options.ttl` in\nthe `fetchMethod`.\n\n### `noDeleteOnFetchRejection`\n\nIf a `fetchMethod` throws an error or returns a rejected promise,\nthen by default, any existing stale value will be removed from\nthe cache.\n\nIf `noDeleteOnFetchRejection` is set to `true`, then this\nbehavior is suppressed, and the stale value remains in the cache\nin the case of a rejected `fetchMethod`.\n\nThis is important in cases where a `fetchMethod` is _only_ called\nas a background update while the stale value is returned, when\n`allowStale` is used.\n\nThis is implicitly in effect when `allowStaleOnFetchRejection` is\nset.\n\nThis may be set in calls to `fetch()`, or defaulted on the\nconstructor, or overridden by modifying the options object in the\n`fetchMethod`.\n\n### `allowStaleOnFetchRejection`\n\nSet to true to return a stale value from the cache when a\n`fetchMethod` throws an error or returns a rejected Promise.\n\nIf a `fetchMethod` fails, and there is no stale value available,\nthe `fetch()` will resolve to `undefined`. Ie, all `fetchMethod`\nerrors are suppressed.\n\nImplies `noDeleteOnFetchRejection`.\n\nThis may be set in calls to `fetch()`, or defaulted on the\nconstructor, or overridden by modifying the options object in the\n`fetchMethod`.\n\n### `allowStaleOnFetchAbort`\n\nSet to true to return a stale value from the cache when the\n`AbortSignal` passed to the `fetchMethod` dispatches an `'abort'`\nevent, whether user-triggered, or due to internal cache behavior.\n\nUnless `ignoreFetchAbort` is also set, the underlying\n`fetchMethod` will still be considered canceled, and any value\nit returns will be ignored and not cached.\n\nCaveat: since fetches are aborted when a new value is explicitly\nset in the cache, this can lead to fetch returning a stale value,\nsince that was the fallback value _at the moment the `fetch()` was\ninitiated_, even though the new updated value is now present in\nthe cache.\n\nFor example:\n\n```ts\nconst cache = new LRUCache<string, any>({\n  ttl: 100,\n  fetchMethod: async (url, oldValue, { signal }) => {\n    const res = await fetch(url, { signal })\n    return await res.json()\n  },\n})\ncache.set('https://example.com/', { some: 'data' })\n// 100ms go by...\nconst result = cache.fetch('https://example.com/')\ncache.set('https://example.com/', { other: 'thing' })\nconsole.log(await result) // { some: 'data' }\nconsole.log(cache.get('https://example.com/')) // { other: 'thing' }\n```\n\n### `ignoreFetchAbort`\n\nSet to true to ignore the `abort` event emitted by the\n`AbortSignal` object passed to `fetchMethod`, and still cache the\nresulting resolution value, as long as it is not `undefined`.\n\nWhen used on its own, this means aborted `fetch()` calls are not\nimmediately resolved or rejected when they are aborted, and\ninstead take the full time to await.\n\nWhen used with `allowStaleOnFetchAbort`, aborted `fetch()` calls\nwill resolve immediately to their stale cached value or\n`undefined`, and will continue to process and eventually update\nthe cache when they resolve, as long as the resulting value is\nnot `undefined`, thus supporting a \"return stale on timeout while\nrefreshing\" mechanism by passing `AbortSignal.timeout(n)` as the\nsignal.\n\nFor example:\n\n```js\nconst c = new LRUCache({\n  ttl: 100,\n  ignoreFetchAbort: true,\n  allowStaleOnFetchAbort: true,\n  fetchMethod: async (key, oldValue, { signal }) => {\n    // note: do NOT pass the signal to fetch()!\n    // let's say this fetch can take a long time.\n    const res = await fetch(`https://slow-backend-server/${key}`)\n    return await res.json()\n  },\n})\n\n// this will return the stale value after 100ms, while still\n// updating in the background for next time.\nconst val = await c.fetch('key', { signal: AbortSignal.timeout(100) })\n```\n\n**Note**: regardless of this setting, an `abort` event _is still\nemitted on the `AbortSignal` object_, so may result in invalid\nresults when passed to other underlying APIs that use\nAbortSignals.\n\nThis may be overridden on the `fetch()` call or in the\n`fetchMethod` itself.\n\n### `dispose` (read only)\n\nFunction that is called on items when they are dropped from the\ncache, as `this.dispose(value, key, reason)`.\n\nThis can be handy if you want to close file descriptors or do\nother cleanup tasks when items are no longer stored in the cache.\n\n**NOTE**: It is called _before_ the item has been fully removed\nfrom the cache, so if you want to put it right back in, you need\nto wait until the next tick. If you try to add it back in during\nthe `dispose()` function call, it will break things in subtle and\nweird ways.\n\nUnlike several other options, this may _not_ be overridden by\npassing an option to `set()`, for performance reasons.\n\nThe `reason` will be one of the following strings, corresponding\nto the reason for the item's deletion:\n\n- `evict` Item was evicted to make space for a new addition\n- `set` Item was overwritten by a new value\n- `delete` Item was removed by explicit `cache.delete(key)` or by\n  calling `cache.clear()`, which deletes everything.\n\nThe `dispose()` method is _not_ called for canceled calls to\n`fetchMethod()`. If you wish to handle evictions, overwrites,\nand deletes of in-flight asynchronous fetches, you must use the\n`AbortSignal` provided.\n\nOptional, must be a function.\n\n### `disposeAfter` (read only)\n\nThe same as `dispose`, but called _after_ the entry is completely\nremoved and the cache is once again in a clean state.\n\nIt is safe to add an item right back into the cache at this\npoint. However, note that it is _very_ easy to inadvertently\ncreate infinite recursion in this way.\n\nThe `disposeAfter()` method is _not_ called for canceled calls to\n`fetchMethod()`. If you wish to handle evictions, overwrites,\nand deletes of in-flight asynchronous fetches, you must use the\n`AbortSignal` provided.\n\n### `noDisposeOnSet`\n\nSet to `true` to suppress calling the `dispose()` function if the\nentry key is still accessible within the cache.\n\nThis may be overridden by passing an options object to\n`cache.set()`.\n\nBoolean, default `false`. Only relevant if `dispose` or\n`disposeAfter` options are set.\n\n### `ttl`\n\nMax time to live for items before they are considered stale.\nNote that stale items are NOT preemptively removed by default,\nand MAY live in the cache, contributing to its LRU max, long\nafter they have expired.\n\nAlso, as this cache is optimized for LRU/MRU operations, some of\nthe staleness/TTL checks will reduce performance.\n\nThis is not primarily a TTL cache, and does not make strong TTL\nguarantees. There is no pre-emptive pruning of expired items,\nbut you _may_ set a TTL on the cache, and it will treat expired\nitems as missing when they are fetched, and delete them.\n\nOptional, but must be a positive integer in ms if specified.\n\nThis may be overridden by passing an options object to\n`cache.set()`.\n\nAt least one of `max`, `maxSize`, or `TTL` is required. This\nmust be a positive integer if set.\n\nEven if ttl tracking is enabled, **it is strongly recommended to\nset a `max` to prevent unbounded growth of the cache.** See\n\"Storage Bounds Safety\" below.\n\nIf ttl tracking is enabled, and `max` and `maxSize` are not set,\nand `ttlAutopurge` is not set, then a warning will be emitted\ncautioning about the potential for unbounded memory consumption.\n(The TypeScript definitions will also discourage this.)\n\n### `noUpdateTTL`\n\nBoolean flag to tell the cache to not update the TTL when setting\na new value for an existing key (ie, when updating a value rather\nthan inserting a new value). Note that the TTL value is _always_\nset (if provided) when adding a new entry into the cache.\n\nThis may be passed as an option to `cache.set()`.\n\nBoolean, default false.\n\n### `ttlResolution`\n\nMinimum amount of time in ms in which to check for staleness.\nDefaults to `1`, which means that the current time is checked at\nmost once per millisecond.\n\nSet to `0` to check the current time every time staleness is\ntested.\n\nNote that setting this to a higher value _will_ improve\nperformance somewhat while using ttl tracking, albeit at the\nexpense of keeping stale items around a bit longer than intended.\n\n### `ttlAutopurge`\n\nPreemptively remove stale items from the cache.\n\nNote that this may _significantly_ degrade performance,\nespecially if the cache is storing a large number of items. It\nis almost always best to just leave the stale items in the cache,\nand let them fall out as new items are added.\n\nNote that this means that `allowStale` is a bit pointless, as\nstale items will be deleted almost as soon as they expire.\n\nUse with caution!\n\nBoolean, default `false`\n\n### `allowStale`\n\nBy default, if you set `ttl`, it'll only delete stale items from\nthe cache when you `get(key)`. That is, it's not preemptively\npruning items.\n\nIf you set `allowStale:true`, it'll return the stale value as\nwell as deleting it. If you don't set this, then it'll return\n`undefined` when you try to get a stale entry.\n\nNote that when a stale entry is fetched, _even if it is returned\ndue to `allowStale` being set_, it is removed from the cache\nimmediately. You can immediately put it back in the cache if you\nwish, thus resetting the TTL.\n\nThis may be overridden by passing an options object to\n`cache.get()`. The `cache.has()` method will always return\n`false` for stale items.\n\nBoolean, default false, only relevant if `ttl` is set.\n\n### `noDeleteOnStaleGet`\n\nWhen using time-expiring entries with `ttl`, by default stale\nitems will be removed from the cache when the key is accessed\nwith `cache.get()`.\n\nSetting `noDeleteOnStaleGet` to `true` will cause stale items to\nremain in the cache, until they are explicitly deleted with\n`cache.delete(key)`, or retrieved with `noDeleteOnStaleGet` set\nto `false`.\n\nThis may be overridden by passing an options object to\n`cache.get()`.\n\nBoolean, default false, only relevant if `ttl` is set.\n\n### `updateAgeOnGet`\n\nWhen using time-expiring entries with `ttl`, setting this to\n`true` will make each item's age reset to 0 whenever it is\nretrieved from cache with `get()`, causing it to not expire. (It\ncan still fall out of cache based on recency of use, of course.)\n\nThis may be overridden by passing an options object to\n`cache.get()`.\n\nBoolean, default false, only relevant if `ttl` is set.\n\n### `updateAgeOnHas`\n\nWhen using time-expiring entries with `ttl`, setting this to\n`true` will make each item's age reset to 0 whenever its presence\nin the cache is checked with `has()`, causing it to not expire.\n(It can still fall out of cache based on recency of use, of\ncourse.)\n\nThis may be overridden by passing an options object to\n`cache.has()`.\n\nBoolean, default false, only relevant if `ttl` is set.\n\n## API\n\n### `new LRUCache<K, V, FC = unknown>(options)`\n\nCreate a new LRUCache. All options are documented above, and are\non the cache as public members.\n\nThe `K` and `V` types define the key and value types,\nrespectively. The optional `FC` type defines the type of the\n`context` object passed to `cache.fetch()`.\n\nKeys and values **must not** be `null` or `undefined`.\n\n### `cache.max`, `cache.maxSize`, `cache.allowStale`,\n\n`cache.noDisposeOnSet`, `cache.sizeCalculation`, `cache.dispose`,\n`cache.maxSize`, `cache.ttl`, `cache.updateAgeOnGet`,\n`cache.updateAgeOnHas`\n\nAll option names are exposed as public members on the cache\nobject.\n\nThese are intended for read access only. Changing them during\nprogram operation can cause undefined behavior.\n\n### `cache.size`\n\nThe total number of items held in the cache at the current\nmoment.\n\n### `cache.calculatedSize`\n\nThe total size of items in cache when using size tracking.\n\n### `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet, start, status }])`\n\nAdd a value to the cache.\n\nOptional options object may contain `ttl` and `sizeCalculation`\nas described above, which default to the settings on the cache\nobject.\n\nIf `start` is provided, then that will set the effective start\ntime for the TTL calculation. Note that this must be a previous\nvalue of `performance.now()` if supported, or a previous value of\n`Date.now()` if not.\n\nOptions object may also include `size`, which will prevent\ncalling the `sizeCalculation` function and just use the specified\nnumber if it is a positive integer, and `noDisposeOnSet` which\nwill prevent calling a `dispose` function in the case of\noverwrites.\n\nIf the `size` (or return value of `sizeCalculation`) for a given\nentry is greater than `maxEntrySize`, then the item will not be\nadded to the cache.\n\nWill update the recency of the entry.\n\nReturns the cache object.\n\nFor the usage of the `status` option, see **Status Tracking**\nbelow.\n\nIf the value is `undefined`, then this is an alias for\n`cache.delete(key)`. `undefined` is never stored in the cache.\nSee **Storing Undefined Values** below.\n\n### `get(key, { updateAgeOnGet, allowStale, status } = {}) => value`\n\nReturn a value from the cache.\n\nWill update the recency of the cache entry found.\n\nIf the key is not found, `get()` will return `undefined`.\n\nFor the usage of the `status` option, see **Status Tracking**\nbelow.\n\n### `info(key) => Entry | undefined`\n\nReturn an `Entry` object containing the currently cached value,\nas well as ttl and size information if available. Returns\nundefined if the key is not found in the cache.\n\nUnlike `dump()` (which is designed to be portable and survive\nserialization), the `start` value is always the current\ntimestamp, and the `ttl` is a calculated remaining time to live\n(negative if expired).\n\nNote that stale values are always returned, rather than being\npruned and treated as if they were not in the cache. If you wish\nto exclude stale entries, guard against a negative `ttl` value.\n\n### `async fetch(key, options = {}) => Promise`\n\nThe following options are supported:\n\n- `updateAgeOnGet`\n- `allowStale`\n- `size`\n- `sizeCalculation`\n- `ttl`\n- `noDisposeOnSet`\n- `forceRefresh`\n- `status` - See **Status Tracking** below.\n- `signal` - AbortSignal can be used to cancel the `fetch()`.\n  Note that the `signal` option provided to the `fetchMethod` is\n  a different object, because it must also respond to internal\n  cache state changes, but aborting this signal will abort the\n  one passed to `fetchMethod` as well.\n- `context` - sets the `context` option passed to the underlying\n  `fetchMethod`.\n\nIf the value is in the cache and not stale, then the returned\nPromise resolves to the value.\n\nIf not in the cache, or beyond its TTL staleness, then\n`fetchMethod(key, staleValue, { options, signal, context })` is\ncalled, and the value returned will be added to the cache once\nresolved.\n\nIf called with `allowStale`, and an asynchronous fetch is\ncurrently in progress to reload a stale value, then the former\nstale value will be returned.\n\nIf called with `forceRefresh`, then the cached item will be\nre-fetched, even if it is not stale. However, if `allowStale` is\nset, then the old value will still be returned. This is useful\nin cases where you want to force a reload of a cached value. If\na background fetch is already in progress, then `forceRefresh`\nhas no effect.\n\nMultiple fetches for the same `key` will only call `fetchMethod`\na single time, and all will be resolved when the value is\nresolved, even if different options are used.\n\nIf `fetchMethod` is not specified, then this is effectively an\nalias for `Promise.resolve(cache.get(key))`.\n\nWhen the fetch method resolves to a value, if the fetch has not\nbeen aborted due to deletion, eviction, or being overwritten,\nthen it is added to the cache using the options provided.\n\nIf the key is evicted or deleted before the `fetchMethod`\nresolves, then the AbortSignal passed to the `fetchMethod` will\nreceive an `abort` event, and the promise returned by `fetch()`\nwill reject with the reason for the abort.\n\nIf a `signal` is passed to the `fetch()` call, then aborting the\nsignal will abort the fetch and cause the `fetch()` promise to\nreject with the reason provided.\n\n#### Setting `context`\n\nIf an `FC` type is set to a type other than `unknown`, `void`, or\n`undefined` in the LRUCache constructor, then all\ncalls to `cache.fetch()` _must_ provide a `context` option. If\nset to `undefined` or `void`, then calls to fetch _must not_\nprovide a `context` option.\n\nThe `context` param allows you to provide arbitrary data that\nmight be relevant in the course of fetching the data. It is only\nrelevant for the course of a single `fetch()` operation, and\ndiscarded afterwards.\n\n#### Note: `fetch()` calls are inflight-unique\n\nIf you call `fetch()` multiple times with the same key value,\nthen every call after the first will resolve on the same\npromise<sup>1</sup>,\n_even if they have different settings that would otherwise change\nthe behvavior of the fetch_, such as `noDeleteOnFetchRejection`\nor `ignoreFetchAbort`.\n\nIn most cases, this is not a problem (in fact, only fetching\nsomething once is what you probably want, if you're caching in\nthe first place). If you are changing the fetch() options\ndramatically between runs, there's a good chance that you might\nbe trying to fit divergent semantics into a single object, and\nwould be better off with multiple cache instances.\n\n**1**: Ie, they're not the \"same Promise\", but they resolve at\nthe same time, because they're both waiting on the same\nunderlying fetchMethod response.\n\n### `peek(key, { allowStale } = {}) => value`\n\nLike `get()` but doesn't update recency or delete stale items.\n\nReturns `undefined` if the item is stale, unless `allowStale` is\nset either on the cache or in the options object.\n\n### `has(key, { updateAgeOnHas, status } = {}) => Boolean`\n\nCheck if a key is in the cache, without updating the recency of\nuse. Age is updated if `updateAgeOnHas` is set to `true` in\neither the options or the constructor.\n\nWill return `false` if the item is stale, even though it is\ntechnically in the cache. The difference can be determined (if\nit matters) by using a `status` argument, and inspecting the\n`has` field.\n\nFor the usage of the `status` option, see **Status Tracking**\nbelow.\n\n### `delete(key)`\n\nDeletes a key out of the cache.\n\nReturns `true` if the key was deleted, `false` otherwise.\n\n### `clear()`\n\nClear the cache entirely, throwing away all values.\n\n### `keys()`\n\nReturn a generator yielding the keys in the cache, in order from\nmost recently used to least recently used.\n\n### `rkeys()`\n\nReturn a generator yielding the keys in the cache, in order from\nleast recently used to most recently used.\n\n### `values()`\n\nReturn a generator yielding the values in the cache, in order\nfrom most recently used to least recently used.\n\n### `rvalues()`\n\nReturn a generator yielding the values in the cache, in order\nfrom least recently used to most recently used.\n\n### `entries()`\n\nReturn a generator yielding `[key, value]` pairs, in order from\nmost recently used to least recently used.\n\n### `rentries()`\n\nReturn a generator yielding `[key, value]` pairs, in order from\nleast recently used to most recently used.\n\n### `find(fn, [getOptions])`\n\nFind a value for which the supplied `fn` method returns a truthy\nvalue, similar to `Array.find()`.\n\n`fn` is called as `fn(value, key, cache)`.\n\nThe optional `getOptions` are applied to the resulting `get()` of\nthe item found.\n\n### `dump()`\n\nReturn an array of `[key, entry]` objects which can be passed to\n`cache.load()`\n\nThe `start` fields are calculated relative to a portable\n`Date.now()` timestamp, even if `performance.now()` is available.\n\nStale entries are always included in the `dump`, even if\n`allowStale` is false.\n\nNote: this returns an actual array, not a generator, so it can be\nmore easily passed around.\n\n### `load(entries)`\n\nReset the cache and load in the items in `entries` in the order\nlisted. Note that the shape of the resulting cache may be\ndifferent if the same options are not used in both caches.\n\nThe `start` fields are assumed to be calculated relative to a\nportable `Date.now()` timestamp, even if `performance.now()` is\navailable.\n\n### `purgeStale()`\n\nDelete any stale entries. Returns `true` if anything was\nremoved, `false` otherwise.\n\n### `getRemainingTTL(key)`\n\nReturn the number of ms left in the item's TTL. If item is not\nin cache, returns `0`. Returns `Infinity` if item is in cache\nwithout a defined TTL.\n\n### `forEach(fn, [thisp])`\n\nCall the `fn` function with each set of `fn(value, key, cache)`\nin the LRU cache, from most recent to least recently used.\n\nDoes not affect recency of use.\n\nIf `thisp` is provided, function will be called in the\n`this`-context of the provided object.\n\n### `rforEach(fn, [thisp])`\n\nSame as `cache.forEach(fn, thisp)`, but in order from least\nrecently used to most recently used.\n\n### `pop()`\n\nEvict the least recently used item, returning its value.\n\nReturns `undefined` if cache is empty.\n\n## Status Tracking\n\nOccasionally, it may be useful to track the internal behavior of\nthe cache, particularly for logging, debugging, or for behavior\nwithin the `fetchMethod`. To do this, you can pass a `status`\nobject to the `get()`, `set()`, `has()`, and `fetch()` methods.\n\nThe `status` option should be a plain JavaScript object.\n\nThe following fields will be set appropriately:\n\n```ts\ninterface Status<V> {\n  /**\n   * The status of a set() operation.\n   *\n   * - add: the item was not found in the cache, and was added\n   * - update: the item was in the cache, with the same value provided\n   * - replace: the item was in the cache, and replaced\n   * - miss: the item was not added to the cache for some reason\n   */\n  set?: 'add' | 'update' | 'replace' | 'miss'\n\n  /**\n   * the ttl stored for the item, or undefined if ttls are not used.\n   */\n  ttl?: LRUMilliseconds\n\n  /**\n   * the start time for the item, or undefined if ttls are not used.\n   */\n  start?: LRUMilliseconds\n\n  /**\n   * The timestamp used for TTL calculation\n   */\n  now?: LRUMilliseconds\n\n  /**\n   * the remaining ttl for the item, or undefined if ttls are not used.\n   */\n  remainingTTL?: LRUMilliseconds\n\n  /**\n   * The calculated size for the item, if sizes are used.\n   */\n  size?: LRUSize\n\n  /**\n   * A flag indicating that the item was not stored, due to exceeding the\n   * {@link maxEntrySize}\n   */\n  maxEntrySizeExceeded?: true\n\n  /**\n   * The old value, specified in the case of `set:'update'` or\n   * `set:'replace'`\n   */\n  oldValue?: V\n\n  /**\n   * The results of a {@link has} operation\n   *\n   * - hit: the item was found in the cache\n   * - stale: the item was found in the cache, but is stale\n   * - miss: the item was not found in the cache\n   */\n  has?: 'hit' | 'stale' | 'miss'\n\n  /**\n   * The status of a {@link fetch} operation.\n   * Note that this can change as the underlying fetch() moves through\n   * various states.\n   *\n   * - inflight: there is another fetch() for this key which is in process\n   * - get: there is no fetchMethod, so {@link get} was called.\n   * - miss: the item is not in cache, and will be fetched.\n   * - hit: the item is in the cache, and was resolved immediately.\n   * - stale: the item is in the cache, but stale.\n   * - refresh: the item is in the cache, and not stale, but\n   *   {@link forceRefresh} was specified.\n   */\n  fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n  /**\n   * The {@link fetchMethod} was called\n   */\n  fetchDispatched?: true\n\n  /**\n   * The cached value was updated after a successful call to fetchMethod\n   */\n  fetchUpdated?: true\n\n  /**\n   * The reason for a fetch() rejection.  Either the error raised by the\n   * {@link fetchMethod}, or the reason for an AbortSignal.\n   */\n  fetchError?: Error\n\n  /**\n   * The fetch received an abort signal\n   */\n  fetchAborted?: true\n\n  /**\n   * The abort signal received was ignored, and the fetch was allowed to\n   * continue.\n   */\n  fetchAbortIgnored?: true\n\n  /**\n   * The fetchMethod promise resolved successfully\n   */\n  fetchResolved?: true\n\n  /**\n   * The results of the fetchMethod promise were stored in the cache\n   */\n  fetchUpdated?: true\n\n  /**\n   * The fetchMethod promise was rejected\n   */\n  fetchRejected?: true\n\n  /**\n   * The status of a {@link get} operation.\n   *\n   * - fetching: The item is currently being fetched.  If a previous value is\n   *   present and allowed, that will be returned.\n   * - stale: The item is in the cache, and is stale.\n   * - hit: the item is in the cache\n   * - miss: the item is not in the cache\n   */\n  get?: 'stale' | 'hit' | 'miss'\n\n  /**\n   * A fetch or get operation returned a stale value.\n   */\n  returnedStale?: true\n}\n```\n\n## Storage Bounds Safety\n\nThis implementation aims to be as flexible as possible, within\nthe limits of safe memory consumption and optimal performance.\n\nAt initial object creation, storage is allocated for `max` items.\nIf `max` is set to zero, then some performance is lost, and item\ncount is unbounded. Either `maxSize` or `ttl` _must_ be set if\n`max` is not specified.\n\nIf `maxSize` is set, then this creates a safe limit on the\nmaximum storage consumed, but without the performance benefits of\npre-allocation. When `maxSize` is set, every item _must_ provide\na size, either via the `sizeCalculation` method provided to the\nconstructor, or via a `size` or `sizeCalculation` option provided\nto `cache.set()`. The size of every item _must_ be a positive\ninteger.\n\nIf neither `max` nor `maxSize` are set, then `ttl` tracking must\nbe enabled. Note that, even when tracking item `ttl`, items are\n_not_ preemptively deleted when they become stale, unless\n`ttlAutopurge` is enabled. Instead, they are only purged the\nnext time the key is requested. Thus, if `ttlAutopurge`, `max`,\nand `maxSize` are all not set, then the cache will potentially\ngrow unbounded.\n\nIn this case, a warning is printed to standard error. Future\nversions may require the use of `ttlAutopurge` if `max` and\n`maxSize` are not specified.\n\nIf you truly wish to use a cache that is bound _only_ by TTL\nexpiration, consider using a `Map` object, and calling\n`setTimeout` to delete entries when they expire. It will perform\nmuch better than an LRU cache.\n\nHere is an implementation you may use, under the same\n[license](./LICENSE) as this package:\n\n```js\n// a storage-unbounded ttl cache that is not an lru-cache\nconst cache = {\n  data: new Map(),\n  timers: new Map(),\n  set: (k, v, ttl) => {\n    if (cache.timers.has(k)) {\n      clearTimeout(cache.timers.get(k))\n    }\n    cache.timers.set(\n      k,\n      setTimeout(() => cache.delete(k), ttl)\n    )\n    cache.data.set(k, v)\n  },\n  get: k => cache.data.get(k),\n  has: k => cache.data.has(k),\n  delete: k => {\n    if (cache.timers.has(k)) {\n      clearTimeout(cache.timers.get(k))\n    }\n    cache.timers.delete(k)\n    return cache.data.delete(k)\n  },\n  clear: () => {\n    cache.data.clear()\n    for (const v of cache.timers.values()) {\n      clearTimeout(v)\n    }\n    cache.timers.clear()\n  },\n}\n```\n\nIf that isn't to your liking, check out\n[@isaacs/ttlcache](http://npm.im/@isaacs/ttlcache).\n\n## Storing Undefined Values\n\nThis cache never stores undefined values, as `undefined` is used\ninternally in a few places to indicate that a key is not in the\ncache.\n\nYou may call `cache.set(key, undefined)`, but this is just an\nan alias for `cache.delete(key)`. Note that this has the effect\nthat `cache.has(key)` will return _false_ after setting it to\nundefined.\n\n```js\ncache.set(myKey, undefined)\ncache.has(myKey) // false!\n```\n\nIf you need to track `undefined` values, and still note that the\nkey is in the cache, an easy workaround is to use a sigil object\nof your own.\n\n```js\nimport { LRUCache } from 'lru-cache'\nconst undefinedValue = Symbol('undefined')\nconst cache = new LRUCache(...)\nconst mySet = (key, value) =>\n  cache.set(key, value === undefined ? undefinedValue : value)\nconst myGet = (key, value) => {\n  const v = cache.get(key)\n  return v === undefinedValue ? undefined : v\n}\n```\n\n## Performance\n\nAs of January 2022, version 7 of this library is one of the most\nperformant LRU cache implementations in JavaScript.\n\nBenchmarks can be extremely difficult to get right. In\nparticular, the performance of set/get/delete operations on\nobjects will vary _wildly_ depending on the type of key used. V8\nis highly optimized for objects with keys that are short strings,\nespecially integer numeric strings. Thus any benchmark which\ntests _solely_ using numbers as keys will tend to find that an\nobject-based approach performs the best.\n\nNote that coercing _anything_ to strings to use as object keys is\nunsafe, unless you can be 100% certain that no other type of\nvalue will be used. For example:\n\n```js\nconst myCache = {}\nconst set = (k, v) => (myCache[k] = v)\nconst get = k => myCache[k]\n\nset({}, 'please hang onto this for me')\nset('[object Object]', 'oopsie')\n```\n\nAlso beware of \"Just So\" stories regarding performance. Garbage\ncollection of large (especially: deep) object graphs can be\nincredibly costly, with several \"tipping points\" where it\nincreases exponentially. As a result, putting that off until\nlater can make it much worse, and less predictable. If a library\nperforms well, but only in a scenario where the object graph is\nkept shallow, then that won't help you if you are using large\nobjects as keys.\n\nIn general, when attempting to use a library to improve\nperformance (such as a cache like this one), it's best to choose\nan option that will perform well in the sorts of scenarios where\nyou'll actually use it.\n\nThis library is optimized for repeated gets and minimizing\neviction time, since that is the expected need of a LRU. Set\noperations are somewhat slower on average than a few other\noptions, in part because of that optimization. It is assumed\nthat you'll be caching some costly operation, ideally as rarely\nas possible, so optimizing set over get would be unwise.\n\nIf performance matters to you:\n\n1. If it's at all possible to use small integer values as keys,\n   and you can guarantee that no other types of values will be\n   used as keys, then do that, and use a cache such as\n   [lru-fast](https://npmjs.com/package/lru-fast), or\n   [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache)\n   which uses an Object as its data store.\n\n2. Failing that, if at all possible, use short non-numeric\n   strings (ie, less than 256 characters) as your keys, and use\n   [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache).\n\n3. If the types of your keys will be anything else, especially\n   long strings, strings that look like floats, objects, or some\n   mix of types, or if you aren't sure, then this library will\n   work well for you.\n\n   If you do not need the features that this library provides\n   (like asynchronous fetching, a variety of TTL staleness\n   options, and so on), then [mnemonist's\n   LRUMap](https://yomguithereal.github.io/mnemonist/lru-map) is\n   a very good option, and just slightly faster than this module\n   (since it does considerably less).\n\n4. Do not use a `dispose` function, size tracking, or especially\n   ttl behavior, unless absolutely needed. These features are\n   convenient, and necessary in some use cases, and every attempt\n   has been made to make the performance impact minimal, but it\n   isn't nothing.\n\n## Breaking Changes in Version 7\n\nThis library changed to a different algorithm and internal data\nstructure in version 7, yielding significantly better\nperformance, albeit with some subtle changes as a result.\n\nIf you were relying on the internals of LRUCache in version 6 or\nbefore, it probably will not work in version 7 and above.\n\n## Breaking Changes in Version 8\n\n- The `fetchContext` option was renamed to `context`, and may no\n  longer be set on the cache instance itself.\n- Rewritten in TypeScript, so pretty much all the types moved\n  around a lot.\n- The AbortController/AbortSignal polyfill was removed. For this\n  reason, **Node version 16.14.0 or higher is now required**.\n- Internal properties were moved to actual private class\n  properties.\n- Keys and values must not be `null` or `undefined`.\n- Minified export available at `'lru-cache/min'`, for both CJS\n  and MJS builds.\n\n## Changes in Version 9\n\n- Named export only, no default export.\n- AbortController polyfill returned, albeit with a warning when\n  used.\n\nFor more info, see the [change log](CHANGELOG.md).\n",
    "licenseText": "The ISC License\n\nCopyright (c) 2010-2023 Isaac Z. Schlueter and Contributors\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR\nIN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/lru-cache/-/lru-cache-10.2.2.tgz#48206bc114c1252940c41b25b41af5b545aca878",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/lru-cache/-/lru-cache-10.2.2.tgz",
    "hash": "48206bc114c1252940c41b25b41af5b545aca878",
    "integrity": "sha512-9hp3Vp2/hFQUiIwKo8XCeFVnrg8Pk3TYNPIR7tJADKi5YfcF7vEaK7avFHTlSy3kOKYaJQaalfEo6YuXdceBOQ==",
    "registry": "npm",
    "packageName": "lru-cache",
    "cacheIntegrity": "sha512-9hp3Vp2/hFQUiIwKo8XCeFVnrg8Pk3TYNPIR7tJADKi5YfcF7vEaK7avFHTlSy3kOKYaJQaalfEo6YuXdceBOQ== sha1-SCBrwRTBJSlAxBsltBr1tUWsqHg="
  },
  "registry": "npm",
  "hash": "48206bc114c1252940c41b25b41af5b545aca878"
}