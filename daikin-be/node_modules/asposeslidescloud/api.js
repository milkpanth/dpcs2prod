"use strict";
/*
* MIT License

* Copyright (c) 2018 Aspose Pty Ltd

* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:

* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlidesAsyncApi = exports.SlidesApi = void 0;
const configuration_1 = require("./internal/configuration");
const objectSerializer_1 = require("./internal/objectSerializer");
const requestHelper_1 = require("./internal/requestHelper");
const model = require("./model");
__exportStar(require("./model"), exports);
class SlidesApi {
    get configuration() {
        return this._configuration;
    }
    /**
     * @param appSid Client Id.
     * @param appKey Client Secret.
     * @param baseUrl Base api Url.
     * @param authBaseUrl Base authentication Url.
     * @param debugMode A value indicating whether debug mode. In debug mode all requests and responses are logged to console.
     * @param timeout Timeout (in seconds) for an operation. Applies to the Slides operation, not to the HTTP request.
     */
    constructor(appSid, appKey, baseUrl, authBaseUrl, debugMode, timeout) {
        this._configuration = new configuration_1.Configuration(appSid, appKey, baseUrl, authBaseUrl, debugMode, timeout);
    }
    /**
     * Changes the placement of selected shapes on the slide. Aligns shapes to the margins or the edge of the slide or aligns them relative to each other.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param alignmentType Alignment type that will be applied to the shapes.
     * @param alignToSlide If true, shapes will be aligned relative to the slide edges.
     * @param shapes Shapes indexes.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    alignShapes(name, slideIndex, alignmentType, alignToSlide = null, shapes = null, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling alignShapes.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling alignShapes.');
            }
            // verify required parameter 'alignmentType' is not null or undefined
            if (alignmentType === null || alignmentType === undefined) {
                throw new Error('The required parameter "alignmentType" was null or undefined when calling alignShapes.');
            }
            // verify value of enum parameter 'alignmentType' is valid
            if (!Object.keys(model.ShapesAlignmentType).filter(i => model.ShapesAlignmentType[i].toLowerCase() == alignmentType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for alignmentType: ' + alignmentType + '. Must be one of the following: ' + Object.keys(model.ShapesAlignmentType).map(key => model.ShapesAlignmentType[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/align/{alignmentType}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "alignmentType", objectSerializer_1.ObjectSerializer.toString(alignmentType));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "alignToSlide", alignToSlide);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "shapes", shapes);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Shapes");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Changes the placement of selected shapes on the master slide. Aligns shapes to the margins or the edge of the slide or aligns them relative to each other.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param alignmentType Alignment type that will be applied to the shapes.
     * @param alignToSlide If true, shapes will be aligned relative to the slide edges.
     * @param shapes Shapes indexes.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    alignSpecialSlideShapes(name, slideIndex, slideType, alignmentType, alignToSlide = null, shapes = null, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling alignSpecialSlideShapes.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling alignSpecialSlideShapes.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling alignSpecialSlideShapes.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'alignmentType' is not null or undefined
            if (alignmentType === null || alignmentType === undefined) {
                throw new Error('The required parameter "alignmentType" was null or undefined when calling alignSpecialSlideShapes.');
            }
            // verify value of enum parameter 'alignmentType' is valid
            if (!Object.keys(model.ShapesAlignmentType).filter(i => model.ShapesAlignmentType[i].toLowerCase() == alignmentType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for alignmentType: ' + alignmentType + '. Must be one of the following: ' + Object.keys(model.ShapesAlignmentType).map(key => model.ShapesAlignmentType[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes/align/{alignmentType}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "alignmentType", objectSerializer_1.ObjectSerializer.toString(alignmentType));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "alignToSlide", alignToSlide);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "shapes", shapes);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Shapes");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Compresses embedded fonts by removing unused characters.
     * @param name Document name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    compressEmbeddedFonts(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling compressEmbeddedFonts.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/fonts/embedded/compress";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Compresses embedded fonts by removing unused characters.
     * @param document Document data.
     * @param password Document password.
     */
    compressEmbeddedFontsOnline(document, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling compressEmbeddedFontsOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/fonts/embedded/compress";
            const queryParameters = {};
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Convert presentation from request content to format specified.
     * @param document Document data.
     * @param format Export format.
     * @param password Document password.
     * @param storage Document storage.
     * @param fontsFolder Custom fonts folder.
     * @param slides The indices of the slides to be converted. If not specified, all slides are converted by default.
     * @param options Export options.
     */
    convert(document, format, password = null, storage = null, fontsFolder = null, slides = null, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling convert.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling convert.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ExportFormat).filter(i => model.ExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ExportFormat).map(key => model.ExportFormat[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/convert/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "slides", slides);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: options,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Convert presentation from request content to format specified.
     * @param document Document data.
     * @param format Export format.
     * @param outPath Path to save result.
     * @param password Document password.
     * @param storage Document storage.
     * @param fontsFolder Custom fonts folder.
     * @param slides The indices of the slides to be converted. If not specified, all slides are converted by default.
     * @param options Export options.
     */
    convertAndSave(document, format, outPath, password = null, storage = null, fontsFolder = null, slides = null, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling convertAndSave.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling convertAndSave.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ExportFormat).filter(i => model.ExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ExportFormat).map(key => model.ExportFormat[key]).join());
            }
            // verify required parameter 'outPath' is not null or undefined
            if (outPath === null || outPath === undefined) {
                throw new Error('The required parameter "outPath" was null or undefined when calling convertAndSave.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/convert/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "outPath", outPath);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "slides", slides);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: options,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Copy file
     * @param srcPath Source file path e.g. '/folder/file.ext'
     * @param destPath Destination file path
     * @param srcStorageName Source storage name
     * @param destStorageName Destination storage name
     * @param versionId File version ID to copy
     */
    copyFile(srcPath, destPath, srcStorageName = null, destStorageName = null, versionId = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'srcPath' is not null or undefined
            if (srcPath === null || srcPath === undefined) {
                throw new Error('The required parameter "srcPath" was null or undefined when calling copyFile.');
            }
            // verify required parameter 'destPath' is not null or undefined
            if (destPath === null || destPath === undefined) {
                throw new Error('The required parameter "destPath" was null or undefined when calling copyFile.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/storage/file/copy/{srcPath}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "srcPath", objectSerializer_1.ObjectSerializer.toString(srcPath));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destPath", destPath);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "srcStorageName", srcStorageName);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destStorageName", destStorageName);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "versionId", versionId);
            const requestOptions = {
                method: "PUT",
                url: localVarPath,
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Copy folder
     * @param srcPath Source folder path e.g. '/src'
     * @param destPath Destination folder path e.g. '/dst'
     * @param srcStorageName Source storage name
     * @param destStorageName Destination storage name
     */
    copyFolder(srcPath, destPath, srcStorageName = null, destStorageName = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'srcPath' is not null or undefined
            if (srcPath === null || srcPath === undefined) {
                throw new Error('The required parameter "srcPath" was null or undefined when calling copyFolder.');
            }
            // verify required parameter 'destPath' is not null or undefined
            if (destPath === null || destPath === undefined) {
                throw new Error('The required parameter "destPath" was null or undefined when calling copyFolder.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/storage/folder/copy/{srcPath}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "srcPath", objectSerializer_1.ObjectSerializer.toString(srcPath));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destPath", destPath);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "srcStorageName", srcStorageName);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destStorageName", destStorageName);
            const requestOptions = {
                method: "PUT",
                url: localVarPath,
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Copy layoutSlide from source presentation.
     * @param name Document name.
     * @param cloneFrom Name of the document to clone layoutSlide from.
     * @param cloneFromPosition Position of cloned layout slide.
     * @param cloneFromPassword Password for the document to clone layoutSlide from.
     * @param cloneFromStorage Storage of the document to clone layoutSlide from.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    copyLayoutSlide(name, cloneFrom, cloneFromPosition, cloneFromPassword = null, cloneFromStorage = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling copyLayoutSlide.');
            }
            // verify required parameter 'cloneFrom' is not null or undefined
            if (cloneFrom === null || cloneFrom === undefined) {
                throw new Error('The required parameter "cloneFrom" was null or undefined when calling copyLayoutSlide.');
            }
            // verify required parameter 'cloneFromPosition' is not null or undefined
            if (cloneFromPosition === null || cloneFromPosition === undefined) {
                throw new Error('The required parameter "cloneFromPosition" was null or undefined when calling copyLayoutSlide.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/layoutSlides";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "cloneFrom", cloneFrom);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "cloneFromPosition", cloneFromPosition);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "cloneFromStorage", cloneFromStorage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "cloneFromPassword", cloneFromPassword);
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "LayoutSlide");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Copy masterSlide from source presentation.
     * @param name Document name.
     * @param cloneFrom Name of the document to clone masterSlide from.
     * @param cloneFromPosition Position of cloned master slide.
     * @param cloneFromPassword Password for the document to clone masterSlide from.
     * @param cloneFromStorage Storage of the document to clone masterSlide from.
     * @param applyToAll True to apply cloned master slide to every existing slide.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    copyMasterSlide(name, cloneFrom, cloneFromPosition, cloneFromPassword = null, cloneFromStorage = null, applyToAll = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling copyMasterSlide.');
            }
            // verify required parameter 'cloneFrom' is not null or undefined
            if (cloneFrom === null || cloneFrom === undefined) {
                throw new Error('The required parameter "cloneFrom" was null or undefined when calling copyMasterSlide.');
            }
            // verify required parameter 'cloneFromPosition' is not null or undefined
            if (cloneFromPosition === null || cloneFromPosition === undefined) {
                throw new Error('The required parameter "cloneFromPosition" was null or undefined when calling copyMasterSlide.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/masterSlides";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "cloneFrom", cloneFrom);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "cloneFromPosition", cloneFromPosition);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "cloneFromStorage", cloneFromStorage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "applyToAll", applyToAll);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "cloneFromPassword", cloneFromPassword);
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "MasterSlide");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Copy a slide from the current or another presentation.
     * @param name Document name.
     * @param slideToCopy The index of the slide to be copied from the source presentation.
     * @param position The target position at which to copy the slide. Copy to the end by default.
     * @param source Name of the document to copy a slide from.
     * @param sourcePassword Password for the document to copy a slide from.
     * @param sourceStorage Template storage name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    copySlide(name, slideToCopy, position = null, source = null, sourcePassword = null, sourceStorage = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling copySlide.');
            }
            // verify required parameter 'slideToCopy' is not null or undefined
            if (slideToCopy === null || slideToCopy === undefined) {
                throw new Error('The required parameter "slideToCopy" was null or undefined when calling copySlide.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/copy";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "slideToCopy", slideToCopy);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "position", position);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "source", source);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "sourceStorage", sourceStorage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "sourcePassword", sourcePassword);
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Slides");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Add an effect to slide animation.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param effect Animation effect DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createAnimationEffect(name, slideIndex, effect, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createAnimationEffect.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createAnimationEffect.');
            }
            // verify required parameter 'effect' is not null or undefined
            if (effect === null || effect === undefined) {
                throw new Error('The required parameter "effect" was null or undefined when calling createAnimationEffect.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/animation/mainSequence";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: effect,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Set slide animation.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param sequence Animation sequence DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createAnimationInteractiveSequence(name, slideIndex, sequence, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createAnimationInteractiveSequence.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createAnimationInteractiveSequence.');
            }
            // verify required parameter 'sequence' is not null or undefined
            if (sequence === null || sequence === undefined) {
                throw new Error('The required parameter "sequence" was null or undefined when calling createAnimationInteractiveSequence.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/animation/interactiveSequences";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: sequence,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Add an animation effect to a slide interactive sequence.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param sequenceIndex The position of the interactive sequence.
     * @param effect Animation effect DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createAnimationInteractiveSequenceEffect(name, slideIndex, sequenceIndex, effect, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'sequenceIndex' is not null or undefined
            if (sequenceIndex === null || sequenceIndex === undefined) {
                throw new Error('The required parameter "sequenceIndex" was null or undefined when calling createAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'effect' is not null or undefined
            if (effect === null || effect === undefined) {
                throw new Error('The required parameter "effect" was null or undefined when calling createAnimationInteractiveSequenceEffect.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/animation/interactiveSequences/{sequenceIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "sequenceIndex", objectSerializer_1.ObjectSerializer.toString(sequenceIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: effect,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Add a new category to a chart.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param category Category DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createChartCategory(name, slideIndex, shapeIndex, category, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createChartCategory.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createChartCategory.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling createChartCategory.');
            }
            // verify required parameter 'category' is not null or undefined
            if (category === null || category === undefined) {
                throw new Error('The required parameter "category" was null or undefined when calling createChartCategory.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/categories";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: category,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Chart");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Add a new data point to a chart series.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param seriesIndex Series index.
     * @param dataPoint Data point DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createChartDataPoint(name, slideIndex, shapeIndex, seriesIndex, dataPoint, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createChartDataPoint.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createChartDataPoint.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling createChartDataPoint.');
            }
            // verify required parameter 'seriesIndex' is not null or undefined
            if (seriesIndex === null || seriesIndex === undefined) {
                throw new Error('The required parameter "seriesIndex" was null or undefined when calling createChartDataPoint.');
            }
            // verify required parameter 'dataPoint' is not null or undefined
            if (dataPoint === null || dataPoint === undefined) {
                throw new Error('The required parameter "dataPoint" was null or undefined when calling createChartDataPoint.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/series/{seriesIndex}/dataPoints";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "seriesIndex", objectSerializer_1.ObjectSerializer.toString(seriesIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: dataPoint,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Chart");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Add a new series to a chart.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index (must be a chart).
     * @param series Series DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createChartSeries(name, slideIndex, shapeIndex, series, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createChartSeries.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createChartSeries.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling createChartSeries.');
            }
            // verify required parameter 'series' is not null or undefined
            if (series === null || series === undefined) {
                throw new Error('The required parameter "series" was null or undefined when calling createChartSeries.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/series";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: series,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Chart");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Adds the comment on the slide.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param dto Comment DTO.
     * @param shapeIndex Shape index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createComment(name, slideIndex, dto, shapeIndex = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createComment.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createComment.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling createComment.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/comments";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "shapeIndex", shapeIndex);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideComments");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Adds the comment on the slide.
     * @param document Document data.
     * @param slideIndex Slide index.
     * @param dto Comment DTO.
     * @param shapeIndex Shape index.
     * @param password Document password.
     */
    createCommentOnline(document, slideIndex, dto, shapeIndex = null, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling createCommentOnline.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createCommentOnline.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling createCommentOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/slides/{slideIndex}/comments";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "shapeIndex", shapeIndex);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: dto,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Create the folder
     * @param path Folder path to create e.g. 'folder_1/folder_2/'
     * @param storageName Storage name
     */
    createFolder(path = null, storageName = null) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/storage/folder/{path}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "path", objectSerializer_1.ObjectSerializer.toString(path));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storageName", storageName);
            const requestOptions = {
                method: "PUT",
                url: localVarPath,
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Adds an image watermark to each slide of the presentation.  Image can be provided as a part of the form or withing PictureFrame DTO for detailed customization. Both options are applicable simultaneously.
     * @param name Document name.
     * @param image Image data.
     * @param pictureFrame PictureFrame DTO
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createImageWatermark(name, image = null, pictureFrame = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createImageWatermark.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/watermark/image";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: pictureFrame,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (image != null) {
                localVarFiles.push(image);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Adds an image watermark to each slide of the presentation.  Image can be provided as a part of the form or withing PictureFrame DTO for detailed customization. Both options are applicable simultaneously.
     * @param document Document data.
     * @param image Image data.
     * @param pictureFrame PictureFrame DTO.
     * @param password Document password.
     */
    createImageWatermarkOnline(document, image = null, pictureFrame = null, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling createImageWatermarkOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/watermark/image";
            const queryParameters = {};
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: pictureFrame,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            if (image != null) {
                localVarFiles.push(image);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Add new notes slide.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param dto A NotesSlide object with notes slide data.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createNotesSlide(name, slideIndex, dto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createNotesSlide.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createNotesSlide.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling createNotesSlide.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/notesSlide";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "NotesSlide");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Creates new paragraph.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param dto Paragraph DTO.
     * @param position Position of the new paragraph in the list. Default is at the end of the list.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    createParagraph(name, slideIndex, shapeIndex, dto, position = null, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createParagraph.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createParagraph.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling createParagraph.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling createParagraph.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/paragraphs";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "position", position);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Paragraph");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Creates new portion.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param dto Portion DTO.
     * @param position Position of the new portion in the list. Default is at the end of the list.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    createPortion(name, slideIndex, shapeIndex, paragraphIndex, dto, position = null, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createPortion.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createPortion.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling createPortion.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling createPortion.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling createPortion.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}/portions";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "position", position);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Portion");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Create a presentation.
     * @param name Document name.
     * @param data Source presentation binary data.
     * @param inputPassword The password for source presentation.
     * @param password The document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createPresentation(name, data = null, inputPassword = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createPresentation.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "inputPassword", inputPassword);
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (data != null) {
                localVarFiles.push(data);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Document");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Create a presentation from an existing source.
     * @param name Document name.
     * @param sourcePath Source file path.
     * @param sourcePassword Source file password.
     * @param sourceStorage Source storage name.
     * @param password The document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createPresentationFromSource(name, sourcePath = null, sourcePassword = null, sourceStorage = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createPresentationFromSource.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/fromSource";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "sourcePath", sourcePath);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "sourceStorage", sourceStorage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "sourcePassword", sourcePassword);
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Document");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Create a presentation.
     * @param name Document name.
     * @param templatePath Template file path.
     * @param data Document input data.
     * @param templatePassword Template file password.
     * @param templateStorage Template storage name.
     * @param isImageDataEmbedded True if image data is embedded.
     * @param password The document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createPresentationFromTemplate(name, templatePath, data = null, templatePassword = null, templateStorage = null, isImageDataEmbedded = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createPresentationFromTemplate.');
            }
            // verify required parameter 'templatePath' is not null or undefined
            if (templatePath === null || templatePath === undefined) {
                throw new Error('The required parameter "templatePath" was null or undefined when calling createPresentationFromTemplate.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/fromTemplate";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "templatePath", templatePath);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "templateStorage", templateStorage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "isImageDataEmbedded", isImageDataEmbedded);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: data,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "templatePassword", templatePassword);
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "Content-type", "text/plain");
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Document");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Create a section starting at a specified slide index.
     * @param name Document name.
     * @param sectionName Section name.
     * @param slideIndex Slide index (one-based).
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createSection(name, sectionName, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createSection.');
            }
            // verify required parameter 'sectionName' is not null or undefined
            if (sectionName === null || sectionName === undefined) {
                throw new Error('The required parameter "sectionName" was null or undefined when calling createSection.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createSection.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/sections";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "sectionName", sectionName);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "slideIndex", slideIndex);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Sections");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Create new shape.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param dto Shape DTO.
     * @param shapeToClone Optional index for clone shape instead of adding a new one.
     * @param position Position of the new shape in the list. Default is at the end of the list.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    createShape(name, slideIndex, dto = null, shapeToClone = null, position = null, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createShape.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createShape.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "shapeToClone", shapeToClone);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "position", position);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "ShapeBase");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Create a slide.
     * @param name Document name.
     * @param layoutAlias Alias of layout slide for new slide. Alias may be the type of layout, name of layout slide or index
     * @param position The target position at which to create the slide. Add to the end by default.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createSlide(name, layoutAlias = null, position = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createSlide.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "layoutAlias", layoutAlias);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "position", position);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Slides");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Add SmartArt node
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param smartArtIndex Index of the object on the slide among the same type of objects.
     * @param subNode Sub-node path (e.g. \"3\", \"3/nodes/2).
     * @param text Node text.
     * @param position Position to insert a new node.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createSmartArtNode(name, slideIndex, smartArtIndex, subNode = null, text = null, position = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createSmartArtNode.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createSmartArtNode.');
            }
            // verify required parameter 'smartArtIndex' is not null or undefined
            if (smartArtIndex === null || smartArtIndex === undefined) {
                throw new Error('The required parameter "smartArtIndex" was null or undefined when calling createSmartArtNode.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/smartArts/{smartArtIndex}/nodes";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "smartArtIndex", objectSerializer_1.ObjectSerializer.toString(smartArtIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subNode", subNode);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "text", text);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "position", position);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SmartArt");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Add an effect to special slide (master, layout, notes) animation.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param effect Animation effect DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createSpecialSlideAnimationEffect(name, slideIndex, slideType, effect, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createSpecialSlideAnimationEffect.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createSpecialSlideAnimationEffect.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling createSpecialSlideAnimationEffect.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'effect' is not null or undefined
            if (effect === null || effect === undefined) {
                throw new Error('The required parameter "effect" was null or undefined when calling createSpecialSlideAnimationEffect.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/animation/mainSequence";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: effect,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Set special slide (master, layout, notes) animation.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param sequence Animation sequence DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createSpecialSlideAnimationInteractiveSequence(name, slideIndex, slideType, sequence, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createSpecialSlideAnimationInteractiveSequence.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createSpecialSlideAnimationInteractiveSequence.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling createSpecialSlideAnimationInteractiveSequence.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'sequence' is not null or undefined
            if (sequence === null || sequence === undefined) {
                throw new Error('The required parameter "sequence" was null or undefined when calling createSpecialSlideAnimationInteractiveSequence.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/animation/interactiveSequences";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: sequence,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Add an animation effect to a special slide (master, layout, notes) interactive sequence.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param sequenceIndex The position of the interactive sequence.
     * @param effect Animation effect DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createSpecialSlideAnimationInteractiveSequenceEffect(name, slideIndex, slideType, sequenceIndex, effect, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createSpecialSlideAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createSpecialSlideAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling createSpecialSlideAnimationInteractiveSequenceEffect.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'sequenceIndex' is not null or undefined
            if (sequenceIndex === null || sequenceIndex === undefined) {
                throw new Error('The required parameter "sequenceIndex" was null or undefined when calling createSpecialSlideAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'effect' is not null or undefined
            if (effect === null || effect === undefined) {
                throw new Error('The required parameter "effect" was null or undefined when calling createSpecialSlideAnimationInteractiveSequenceEffect.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/animation/interactiveSequences/{sequenceIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "sequenceIndex", objectSerializer_1.ObjectSerializer.toString(sequenceIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: effect,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Creates new paragraph.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapeIndex Shape index.
     * @param dto Paragraph DTO.
     * @param position Position of the new paragraph in the list. Default is at the end of the list.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    createSpecialSlideParagraph(name, slideIndex, slideType, shapeIndex, dto, position = null, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createSpecialSlideParagraph.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createSpecialSlideParagraph.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling createSpecialSlideParagraph.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling createSpecialSlideParagraph.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling createSpecialSlideParagraph.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes/{shapeIndex}/paragraphs";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "position", position);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Paragraph");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Creates new portion.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param dto Portion DTO.
     * @param position Position of the new portion in the list. Default is at the end of the list.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    createSpecialSlidePortion(name, slideIndex, slideType, shapeIndex, paragraphIndex, dto, position = null, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createSpecialSlidePortion.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createSpecialSlidePortion.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling createSpecialSlidePortion.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling createSpecialSlidePortion.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling createSpecialSlidePortion.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling createSpecialSlidePortion.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}/portions";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "position", position);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Portion");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Create new shape.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param dto Shape DTO.
     * @param shapeToClone Optional index for clone shape instead of adding a new one.
     * @param position Position of the new shape in the list. Default is at the end of the list.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    createSpecialSlideShape(name, slideIndex, slideType, dto, shapeToClone = null, position = null, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createSpecialSlideShape.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createSpecialSlideShape.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling createSpecialSlideShape.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling createSpecialSlideShape.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "shapeToClone", shapeToClone);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "position", position);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "ShapeBase");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Creates table cell paragraph.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param rowIndex Row index.
     * @param cellIndex Table cell index.
     * @param dto Paragraph DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createTableCellParagraph(name, slideIndex, shapeIndex, rowIndex, cellIndex, dto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createTableCellParagraph.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createTableCellParagraph.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling createTableCellParagraph.');
            }
            // verify required parameter 'rowIndex' is not null or undefined
            if (rowIndex === null || rowIndex === undefined) {
                throw new Error('The required parameter "rowIndex" was null or undefined when calling createTableCellParagraph.');
            }
            // verify required parameter 'cellIndex' is not null or undefined
            if (cellIndex === null || cellIndex === undefined) {
                throw new Error('The required parameter "cellIndex" was null or undefined when calling createTableCellParagraph.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling createTableCellParagraph.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/rows/{rowIndex}/cells/{cellIndex}/paragraphs";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "rowIndex", objectSerializer_1.ObjectSerializer.toString(rowIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "cellIndex", objectSerializer_1.ObjectSerializer.toString(cellIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Paragraph");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Creates table cell portion.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param rowIndex Row index.
     * @param cellIndex Table cell index.
     * @param paragraphIndex Paragraph index.
     * @param dto Portion DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createTableCellPortion(name, slideIndex, shapeIndex, rowIndex, cellIndex, paragraphIndex, dto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createTableCellPortion.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createTableCellPortion.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling createTableCellPortion.');
            }
            // verify required parameter 'rowIndex' is not null or undefined
            if (rowIndex === null || rowIndex === undefined) {
                throw new Error('The required parameter "rowIndex" was null or undefined when calling createTableCellPortion.');
            }
            // verify required parameter 'cellIndex' is not null or undefined
            if (cellIndex === null || cellIndex === undefined) {
                throw new Error('The required parameter "cellIndex" was null or undefined when calling createTableCellPortion.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling createTableCellPortion.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling createTableCellPortion.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/rows/{rowIndex}/cells/{cellIndex}/paragraphs/{paragraphIndex}/portions";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "rowIndex", objectSerializer_1.ObjectSerializer.toString(rowIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "cellIndex", objectSerializer_1.ObjectSerializer.toString(cellIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Portion");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Inserts the table row in the specified position. If position is not specified, the row add to the end of the table.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param dto Table row data.
     * @param position Position.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createTableRow(name, slideIndex, shapeIndex, dto, position = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createTableRow.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling createTableRow.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling createTableRow.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling createTableRow.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/rows";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "position", position);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "TableRow");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Append module to VBA project
     * @param name Document name.
     * @param moduleDto VBA module DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createVbaModule(name, moduleDto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createVbaModule.');
            }
            // verify required parameter 'moduleDto' is not null or undefined
            if (moduleDto === null || moduleDto === undefined) {
                throw new Error('The required parameter "moduleDto" was null or undefined when calling createVbaModule.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/vbaProject/modules";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: moduleDto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "VbaModule");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Adds a text watermark to each slide of the presentation. Text watermark can be setup via method arguments or withing Shape DTO for detailed customization. Both options are applicable simultaneously.
     * @param name Document name.
     * @param shape Shape DTO
     * @param fontHeight Watermark font height.
     * @param text Watermark text.
     * @param fontName Watermark font name.
     * @param fontColor Watermark font color.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    createWatermark(name, shape = null, fontHeight = null, text = null, fontName = null, fontColor = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling createWatermark.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/watermark";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontHeight", fontHeight);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "text", text);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontName", fontName);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontColor", fontColor);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: shape,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Adds a text watermark to each slide of the presentation. Text watermark can be setup via method arguments or withing Shape DTO for detailed customization. Both options are applicable simultaneously.
     * @param document Document data.
     * @param shape Shape DTO
     * @param fontHeight Watermark font height.
     * @param text Watermark text.
     * @param fontName Watermark font name.
     * @param fontColor Watermark font color.
     * @param password Document password.
     */
    createWatermarkOnline(document, shape = null, fontHeight = null, text = null, fontName = null, fontColor = null, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling createWatermarkOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/watermark";
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontHeight", fontHeight);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "text", text);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontName", fontName);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontColor", fontColor);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: shape,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove animation from a slide.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteAnimation(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteAnimation.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteAnimation.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/animation";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove an effect from slide animation.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param effectIndex Index of the effect to be removed.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteAnimationEffect(name, slideIndex, effectIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteAnimationEffect.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteAnimationEffect.');
            }
            // verify required parameter 'effectIndex' is not null or undefined
            if (effectIndex === null || effectIndex === undefined) {
                throw new Error('The required parameter "effectIndex" was null or undefined when calling deleteAnimationEffect.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/animation/mainSequence/{effectIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "effectIndex", objectSerializer_1.ObjectSerializer.toString(effectIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove an interactive sequence from slide animation.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param sequenceIndex The index of an interactive sequence to be deleted.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteAnimationInteractiveSequence(name, slideIndex, sequenceIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteAnimationInteractiveSequence.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteAnimationInteractiveSequence.');
            }
            // verify required parameter 'sequenceIndex' is not null or undefined
            if (sequenceIndex === null || sequenceIndex === undefined) {
                throw new Error('The required parameter "sequenceIndex" was null or undefined when calling deleteAnimationInteractiveSequence.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/animation/interactiveSequences/{sequenceIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "sequenceIndex", objectSerializer_1.ObjectSerializer.toString(sequenceIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove an effect from slide animation interactive sequence.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param sequenceIndex Interactive sequence index.
     * @param effectIndex Index of the effect to be removed.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteAnimationInteractiveSequenceEffect(name, slideIndex, sequenceIndex, effectIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'sequenceIndex' is not null or undefined
            if (sequenceIndex === null || sequenceIndex === undefined) {
                throw new Error('The required parameter "sequenceIndex" was null or undefined when calling deleteAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'effectIndex' is not null or undefined
            if (effectIndex === null || effectIndex === undefined) {
                throw new Error('The required parameter "effectIndex" was null or undefined when calling deleteAnimationInteractiveSequenceEffect.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/animation/interactiveSequences/{sequenceIndex}/{effectIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "sequenceIndex", objectSerializer_1.ObjectSerializer.toString(sequenceIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "effectIndex", objectSerializer_1.ObjectSerializer.toString(effectIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Clear all interactive sequences from slide animation.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteAnimationInteractiveSequences(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteAnimationInteractiveSequences.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteAnimationInteractiveSequences.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/animation/interactiveSequences";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Clear main sequence in slide animation.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteAnimationMainSequence(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteAnimationMainSequence.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteAnimationMainSequence.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/animation/mainSequence";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove background from a slide.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteBackground(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteBackground.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteBackground.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/background";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideBackground");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Delete a category from a chart.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param categoryIndex Category index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteChartCategory(name, slideIndex, shapeIndex, categoryIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteChartCategory.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteChartCategory.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling deleteChartCategory.');
            }
            // verify required parameter 'categoryIndex' is not null or undefined
            if (categoryIndex === null || categoryIndex === undefined) {
                throw new Error('The required parameter "categoryIndex" was null or undefined when calling deleteChartCategory.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/categories/{categoryIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "categoryIndex", objectSerializer_1.ObjectSerializer.toString(categoryIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Chart");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Delete a data point from a chart series.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param seriesIndex Series index.
     * @param pointIndex Data point index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteChartDataPoint(name, slideIndex, shapeIndex, seriesIndex, pointIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteChartDataPoint.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteChartDataPoint.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling deleteChartDataPoint.');
            }
            // verify required parameter 'seriesIndex' is not null or undefined
            if (seriesIndex === null || seriesIndex === undefined) {
                throw new Error('The required parameter "seriesIndex" was null or undefined when calling deleteChartDataPoint.');
            }
            // verify required parameter 'pointIndex' is not null or undefined
            if (pointIndex === null || pointIndex === undefined) {
                throw new Error('The required parameter "pointIndex" was null or undefined when calling deleteChartDataPoint.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/series/{seriesIndex}/dataPoints/{pointIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "seriesIndex", objectSerializer_1.ObjectSerializer.toString(seriesIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "pointIndex", objectSerializer_1.ObjectSerializer.toString(pointIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Chart");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Delete a series from a chart.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index (must be a chart).
     * @param seriesIndex Series index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteChartSeries(name, slideIndex, shapeIndex, seriesIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteChartSeries.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteChartSeries.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling deleteChartSeries.');
            }
            // verify required parameter 'seriesIndex' is not null or undefined
            if (seriesIndex === null || seriesIndex === undefined) {
                throw new Error('The required parameter "seriesIndex" was null or undefined when calling deleteChartSeries.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/series/{seriesIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "seriesIndex", objectSerializer_1.ObjectSerializer.toString(seriesIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Chart");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Removes comments of the specified author from the presentation. If author value is not provided all comments will be removed.
     * @param name Document name.
     * @param author Author of comments.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteComments(name, author = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteComments.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/comments";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "author", author);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Removes comments of the specified author from the presentation. If author value is not provided all comments will be removed.
     * @param document Document data.
     * @param author Author of comments.
     * @param password Document password.
     */
    deleteCommentsOnline(document, author = null, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling deleteCommentsOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/comments/delete";
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "author", author);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Clean document properties.
     * @param name Document name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteDocumentProperties(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteDocumentProperties.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/documentproperties";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "DocumentProperties");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Delete document property.
     * @param name Document name.
     * @param propertyName The property name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteDocumentProperty(name, propertyName, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteDocumentProperty.');
            }
            // verify required parameter 'propertyName' is not null or undefined
            if (propertyName === null || propertyName === undefined) {
                throw new Error('The required parameter "propertyName" was null or undefined when calling deleteDocumentProperty.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/documentproperties/{propertyName}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "propertyName", objectSerializer_1.ObjectSerializer.toString(propertyName));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "DocumentProperties");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Removes specified embedded font and returns presentation fonts info.
     * @param name Document name.
     * @param fontName Font name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteEmbeddedFont(name, fontName, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteEmbeddedFont.');
            }
            // verify required parameter 'fontName' is not null or undefined
            if (fontName === null || fontName === undefined) {
                throw new Error('The required parameter "fontName" was null or undefined when calling deleteEmbeddedFont.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/fonts/embedded/{fontName}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "fontName", objectSerializer_1.ObjectSerializer.toString(fontName));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "FontsData");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Removes specified embedded font and returns presentation.
     * @param document Document data.
     * @param fontName Font name.
     * @param password Document password.
     */
    deleteEmbeddedFontOnline(document, fontName, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling deleteEmbeddedFontOnline.');
            }
            // verify required parameter 'fontName' is not null or undefined
            if (fontName === null || fontName === undefined) {
                throw new Error('The required parameter "fontName" was null or undefined when calling deleteEmbeddedFontOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/fonts/embedded/{fontName}/delete";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "fontName", objectSerializer_1.ObjectSerializer.toString(fontName));
            const queryParameters = {};
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Delete file
     * @param path File path e.g. '/folder/file.ext'
     * @param storageName Storage name
     * @param versionId File version ID to delete
     */
    deleteFile(path = null, storageName = null, versionId = null) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/storage/file/{path}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "path", objectSerializer_1.ObjectSerializer.toString(path));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storageName", storageName);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "versionId", versionId);
            const requestOptions = {
                method: "DELETE",
                url: localVarPath,
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Delete folder
     * @param path Folder path e.g. '/folder'
     * @param storageName Storage name
     * @param recursive Enable to delete folders, subfolders and files
     */
    deleteFolder(path = null, storageName = null, recursive = null) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/storage/folder/{path}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "path", objectSerializer_1.ObjectSerializer.toString(path));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storageName", storageName);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "recursive", recursive);
            const requestOptions = {
                method: "DELETE",
                url: localVarPath,
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Remove notes slide.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteNotesSlide(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteNotesSlide.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteNotesSlide.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/notesSlide";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Slide");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove a paragraph.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    deleteParagraph(name, slideIndex, shapeIndex, paragraphIndex, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteParagraph.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteParagraph.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling deleteParagraph.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling deleteParagraph.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Paragraphs");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove a range of paragraphs.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param paragraphs The indices of the paragraphs to be deleted; delete all by default.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    deleteParagraphs(name, slideIndex, shapeIndex, paragraphs = null, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteParagraphs.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteParagraphs.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling deleteParagraphs.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/paragraphs";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "paragraphs", paragraphs);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Paragraphs");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Deletes cropped areas of a pictire.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index (must refer to a picture frame).
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Presentation storage.
     */
    deletePictureCroppedAreas(name, slideIndex, shapeIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deletePictureCroppedAreas.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deletePictureCroppedAreas.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling deletePictureCroppedAreas.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/pictureCroppedAreas";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Remove a portion.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param portionIndex Portion index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    deletePortion(name, slideIndex, shapeIndex, paragraphIndex, portionIndex, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deletePortion.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deletePortion.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling deletePortion.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling deletePortion.');
            }
            // verify required parameter 'portionIndex' is not null or undefined
            if (portionIndex === null || portionIndex === undefined) {
                throw new Error('The required parameter "portionIndex" was null or undefined when calling deletePortion.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}/portions/{portionIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "portionIndex", objectSerializer_1.ObjectSerializer.toString(portionIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Portions");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove a range of portions.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param portions The indices of the portions to be deleted; delete all by default.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    deletePortions(name, slideIndex, shapeIndex, paragraphIndex, portions = null, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deletePortions.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deletePortions.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling deletePortions.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling deletePortions.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}/portions";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "portions", portions);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Portions");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Resets all presentation protection settings.
     * @param name Document name.
     * @param password Presentation password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteProtection(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteProtection.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/protection";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "ProtectionProperties");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Resets all presentation protection settings.
     * @param document Document data.
     * @param password Presentation password.
     */
    deleteProtectionOnline(document, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling deleteProtectionOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/protection/delete";
            const queryParameters = {};
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Delete a presentation section.
     * @param name Document name.
     * @param sectionIndex Section index.
     * @param withSlides True to delete the slides related to the deleted section; move them to the remaining sections otherwise.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteSection(name, sectionIndex, withSlides = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteSection.');
            }
            // verify required parameter 'sectionIndex' is not null or undefined
            if (sectionIndex === null || sectionIndex === undefined) {
                throw new Error('The required parameter "sectionIndex" was null or undefined when calling deleteSection.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/sections/{sectionIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "sectionIndex", objectSerializer_1.ObjectSerializer.toString(sectionIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "withSlides", withSlides);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Sections");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Delete presentation sections.
     * @param name Document name.
     * @param sections The indices of the sections to be deleted; delete all by default.
     * @param withSlides True to delete the slides related to the deleted sections; move them to the remaining sections otherwise.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteSections(name, sections = null, withSlides = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteSections.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/sections";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "sections", sections);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "withSlides", withSlides);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Sections");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove a shape.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    deleteShape(name, slideIndex, shapeIndex, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteShape.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteShape.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling deleteShape.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Shapes");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove a range of shapes.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapes The indices of the shapes to be deleted; delete all by default.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    deleteShapes(name, slideIndex, shapes = null, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteShapes.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteShapes.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "shapes", shapes);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Shapes");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Delete a presentation slide by index.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteSlide(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteSlide.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteSlide.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Slides");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Removes comments of the specified author from the slide. If author value is not provided all comments will be removed.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param author Author of comments.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteSlideComments(name, slideIndex, author = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteSlideComments.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteSlideComments.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/comments";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "author", author);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideComments");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Removes comments of the specified author from the slide. If author value is not provided all comments will be removed.
     * @param document Document data.
     * @param slideIndex
     * @param author Author of comments.
     * @param password Document password.
     */
    deleteSlideCommentsOnline(document, slideIndex, author = null, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling deleteSlideCommentsOnline.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteSlideCommentsOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/slides/{slideIndex}/comments/delete";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "author", author);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Delete presentation slides.
     * @param name Document name.
     * @param slides The indices of the slides to be deleted; delete all by default.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteSlides(name, slides = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteSlides.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "slides", slides);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Slides");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Delete SmartArt node
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param smartArtIndex Index of the object on the slide among the same type of objects.
     * @param nodeIndex Root level node index.
     * @param subNode Sub-node path (e.g. \"3\", \"3/nodes/2).
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteSmartArtNode(name, slideIndex, smartArtIndex, nodeIndex, subNode = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteSmartArtNode.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteSmartArtNode.');
            }
            // verify required parameter 'smartArtIndex' is not null or undefined
            if (smartArtIndex === null || smartArtIndex === undefined) {
                throw new Error('The required parameter "smartArtIndex" was null or undefined when calling deleteSmartArtNode.');
            }
            // verify required parameter 'nodeIndex' is not null or undefined
            if (nodeIndex === null || nodeIndex === undefined) {
                throw new Error('The required parameter "nodeIndex" was null or undefined when calling deleteSmartArtNode.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/smartArts/{smartArtIndex}/nodes/{nodeIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "smartArtIndex", objectSerializer_1.ObjectSerializer.toString(smartArtIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "nodeIndex", objectSerializer_1.ObjectSerializer.toString(nodeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subNode", subNode);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SmartArt");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove animation from a special slide (master, layout, notes).
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteSpecialSlideAnimation(name, slideIndex, slideType, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteSpecialSlideAnimation.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteSpecialSlideAnimation.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling deleteSpecialSlideAnimation.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/animation";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove an effect from special slide (master, layout, notes) animation.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param effectIndex Index of the effect to be removed.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteSpecialSlideAnimationEffect(name, slideIndex, slideType, effectIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteSpecialSlideAnimationEffect.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteSpecialSlideAnimationEffect.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling deleteSpecialSlideAnimationEffect.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'effectIndex' is not null or undefined
            if (effectIndex === null || effectIndex === undefined) {
                throw new Error('The required parameter "effectIndex" was null or undefined when calling deleteSpecialSlideAnimationEffect.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/animation/mainSequence/{effectIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "effectIndex", objectSerializer_1.ObjectSerializer.toString(effectIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove an interactive sequence from special slide (master, layout, notes) animation.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param sequenceIndex The index of an interactive sequence to be deleted.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteSpecialSlideAnimationInteractiveSequence(name, slideIndex, slideType, sequenceIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteSpecialSlideAnimationInteractiveSequence.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteSpecialSlideAnimationInteractiveSequence.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling deleteSpecialSlideAnimationInteractiveSequence.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'sequenceIndex' is not null or undefined
            if (sequenceIndex === null || sequenceIndex === undefined) {
                throw new Error('The required parameter "sequenceIndex" was null or undefined when calling deleteSpecialSlideAnimationInteractiveSequence.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/animation/interactiveSequences/{sequenceIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "sequenceIndex", objectSerializer_1.ObjectSerializer.toString(sequenceIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove an effect from special slide (master, layout, notes) animation interactive sequence.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param sequenceIndex Interactive sequence index.
     * @param effectIndex Index of the effect to be removed.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteSpecialSlideAnimationInteractiveSequenceEffect(name, slideIndex, slideType, sequenceIndex, effectIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteSpecialSlideAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteSpecialSlideAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling deleteSpecialSlideAnimationInteractiveSequenceEffect.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'sequenceIndex' is not null or undefined
            if (sequenceIndex === null || sequenceIndex === undefined) {
                throw new Error('The required parameter "sequenceIndex" was null or undefined when calling deleteSpecialSlideAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'effectIndex' is not null or undefined
            if (effectIndex === null || effectIndex === undefined) {
                throw new Error('The required parameter "effectIndex" was null or undefined when calling deleteSpecialSlideAnimationInteractiveSequenceEffect.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/animation/interactiveSequences/{sequenceIndex}/{effectIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "sequenceIndex", objectSerializer_1.ObjectSerializer.toString(sequenceIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "effectIndex", objectSerializer_1.ObjectSerializer.toString(effectIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Clear all interactive sequences from special slide (master, layout, notes) animation.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteSpecialSlideAnimationInteractiveSequences(name, slideIndex, slideType, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteSpecialSlideAnimationInteractiveSequences.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteSpecialSlideAnimationInteractiveSequences.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling deleteSpecialSlideAnimationInteractiveSequences.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/animation/interactiveSequences";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Clear main sequence in special slide (master, layout, notes) animation.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteSpecialSlideAnimationMainSequence(name, slideIndex, slideType, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteSpecialSlideAnimationMainSequence.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteSpecialSlideAnimationMainSequence.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling deleteSpecialSlideAnimationMainSequence.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/animation/mainSequence";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove a paragraph.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    deleteSpecialSlideParagraph(name, slideIndex, slideType, shapeIndex, paragraphIndex, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteSpecialSlideParagraph.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteSpecialSlideParagraph.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling deleteSpecialSlideParagraph.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling deleteSpecialSlideParagraph.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling deleteSpecialSlideParagraph.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Paragraphs");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove a range of paragraphs.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapeIndex Shape index.
     * @param paragraphs The indices of the shapes to be deleted; delete all by default.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    deleteSpecialSlideParagraphs(name, slideIndex, slideType, shapeIndex, paragraphs = null, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteSpecialSlideParagraphs.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteSpecialSlideParagraphs.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling deleteSpecialSlideParagraphs.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling deleteSpecialSlideParagraphs.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes/{shapeIndex}/paragraphs";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "paragraphs", paragraphs);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Paragraphs");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove a portion.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param portionIndex Portion index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    deleteSpecialSlidePortion(name, slideIndex, slideType, shapeIndex, paragraphIndex, portionIndex, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteSpecialSlidePortion.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteSpecialSlidePortion.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling deleteSpecialSlidePortion.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling deleteSpecialSlidePortion.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling deleteSpecialSlidePortion.');
            }
            // verify required parameter 'portionIndex' is not null or undefined
            if (portionIndex === null || portionIndex === undefined) {
                throw new Error('The required parameter "portionIndex" was null or undefined when calling deleteSpecialSlidePortion.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}/portions/{portionIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "portionIndex", objectSerializer_1.ObjectSerializer.toString(portionIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Portions");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove a range of portions.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param portions The indices of the shapes to be deleted; delete all by default.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    deleteSpecialSlidePortions(name, slideIndex, slideType, shapeIndex, paragraphIndex, portions = null, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteSpecialSlidePortions.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteSpecialSlidePortions.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling deleteSpecialSlidePortions.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling deleteSpecialSlidePortions.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling deleteSpecialSlidePortions.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}/portions";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "portions", portions);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Portions");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove a shape.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapeIndex Shape index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    deleteSpecialSlideShape(name, slideIndex, slideType, shapeIndex, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteSpecialSlideShape.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteSpecialSlideShape.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling deleteSpecialSlideShape.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling deleteSpecialSlideShape.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes/{shapeIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Shapes");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Remove a range of shapes.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapes The indices of the shapes to be deleted; delete all by default.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    deleteSpecialSlideShapes(name, slideIndex, slideType, shapes = null, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteSpecialSlideShapes.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteSpecialSlideShapes.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling deleteSpecialSlideShapes.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "shapes", shapes);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Shapes");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Delete cell paragraph.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param rowIndex Row index.
     * @param cellIndex Table cell index.
     * @param paragraphIndex Paragraph index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteTableCellParagraph(name, slideIndex, shapeIndex, rowIndex, cellIndex, paragraphIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteTableCellParagraph.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteTableCellParagraph.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling deleteTableCellParagraph.');
            }
            // verify required parameter 'rowIndex' is not null or undefined
            if (rowIndex === null || rowIndex === undefined) {
                throw new Error('The required parameter "rowIndex" was null or undefined when calling deleteTableCellParagraph.');
            }
            // verify required parameter 'cellIndex' is not null or undefined
            if (cellIndex === null || cellIndex === undefined) {
                throw new Error('The required parameter "cellIndex" was null or undefined when calling deleteTableCellParagraph.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling deleteTableCellParagraph.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/rows/{rowIndex}/cells/{cellIndex}/paragraphs/{paragraphIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "rowIndex", objectSerializer_1.ObjectSerializer.toString(rowIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "cellIndex", objectSerializer_1.ObjectSerializer.toString(cellIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Paragraphs");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Delete table ell portion.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param rowIndex Row index.
     * @param cellIndex Table cell index.
     * @param paragraphIndex Paragraph index.
     * @param portionIndex Portion index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteTableCellPortion(name, slideIndex, shapeIndex, rowIndex, cellIndex, paragraphIndex, portionIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteTableCellPortion.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteTableCellPortion.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling deleteTableCellPortion.');
            }
            // verify required parameter 'rowIndex' is not null or undefined
            if (rowIndex === null || rowIndex === undefined) {
                throw new Error('The required parameter "rowIndex" was null or undefined when calling deleteTableCellPortion.');
            }
            // verify required parameter 'cellIndex' is not null or undefined
            if (cellIndex === null || cellIndex === undefined) {
                throw new Error('The required parameter "cellIndex" was null or undefined when calling deleteTableCellPortion.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling deleteTableCellPortion.');
            }
            // verify required parameter 'portionIndex' is not null or undefined
            if (portionIndex === null || portionIndex === undefined) {
                throw new Error('The required parameter "portionIndex" was null or undefined when calling deleteTableCellPortion.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/rows/{rowIndex}/cells/{cellIndex}/paragraphs/{paragraphIndex}/portions/{portionIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "rowIndex", objectSerializer_1.ObjectSerializer.toString(rowIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "cellIndex", objectSerializer_1.ObjectSerializer.toString(cellIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "portionIndex", objectSerializer_1.ObjectSerializer.toString(portionIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Portions");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Deletes the table row.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param rowIndex Row index.
     * @param withAttachedRows Also delete all attached rows.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteTableRow(name, slideIndex, shapeIndex, rowIndex, withAttachedRows = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteTableRow.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling deleteTableRow.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling deleteTableRow.');
            }
            // verify required parameter 'rowIndex' is not null or undefined
            if (rowIndex === null || rowIndex === undefined) {
                throw new Error('The required parameter "rowIndex" was null or undefined when calling deleteTableRow.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/rows/{rowIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "rowIndex", objectSerializer_1.ObjectSerializer.toString(rowIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "withAttachedRows", withAttachedRows);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Table");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Removes unused layout slides.
     * @param name Document name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteUnusedLayoutSlides(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteUnusedLayoutSlides.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/layoutSlides";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "LayoutSlides");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Removes unused layout slides.
     * @param document Document data
     * @param password Document password.
     */
    deleteUnusedLayoutSlidesOnline(document, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling deleteUnusedLayoutSlidesOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/layoutSlides/delete";
            const queryParameters = {};
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Removes unused master slides.
     * @param name Document name.
     * @param ignorePreserveField Determines, whether this method should remove unused master even if its             preserve property is set to true.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteUnusedMasterSlides(name, ignorePreserveField = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteUnusedMasterSlides.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/masterSlides";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "ignorePreserveField", ignorePreserveField);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "MasterSlides");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Removes unused master slides.
     * @param document Document data
     * @param ignorePreserveField Determines, whether this method should remove unused master even if its             preserve property is set to true.
     * @param password Document password.
     */
    deleteUnusedMasterSlidesOnline(document, ignorePreserveField = null, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling deleteUnusedMasterSlidesOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/masterSlides/delete";
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "ignorePreserveField", ignorePreserveField);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Delete module from VBA project.
     * @param name Document name.
     * @param moduleIndex The index of the macros module to remove.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteVbaModule(name, moduleIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteVbaModule.');
            }
            // verify required parameter 'moduleIndex' is not null or undefined
            if (moduleIndex === null || moduleIndex === undefined) {
                throw new Error('The required parameter "moduleIndex" was null or undefined when calling deleteVbaModule.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/vbaProject/modules/{moduleIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "moduleIndex", objectSerializer_1.ObjectSerializer.toString(moduleIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "VbaProject");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Removes shapes with name \&quot;watermark\&quot; from the presentation.
     * @param name Document name.
     * @param shapeName Name of the watermark shape. If null, default value \"watermark\"is used.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    deleteWatermark(name, shapeName = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling deleteWatermark.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/watermark/delete";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "shapeName", shapeName);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "DELETE",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Removes shapes with name \&quot;watermark\&quot; from the presentation.
     * @param document Document data.
     * @param shapeName Name of the watermark shape. If null, default value \"watermark\"is used.
     * @param password Document password.
     */
    deleteWatermarkOnline(document, shapeName = null, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling deleteWatermarkOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/watermark/delete";
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "shapeName", shapeName);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Download file
     * @param path File path e.g. '/folder/file.ext'
     * @param storageName Storage name
     * @param versionId File version ID to download
     */
    downloadFile(path = null, storageName = null, versionId = null) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/storage/file/{path}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "path", objectSerializer_1.ObjectSerializer.toString(path));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storageName", storageName);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "versionId", versionId);
            const requestOptions = {
                method: "GET",
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get image in specified format.
     * @param name Document name.
     * @param index Image index.
     * @param format Export format (png, jpg, gif).
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    downloadImage(name, index, format, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling downloadImage.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new Error('The required parameter "index" was null or undefined when calling downloadImage.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling downloadImage.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ImageExportFormat).filter(i => model.ImageExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ImageExportFormat).map(key => model.ImageExportFormat[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/images/{index}/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "index", objectSerializer_1.ObjectSerializer.toString(index));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get image binary data.
     * @param name Document name.
     * @param index Image index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    downloadImageDefaultFormat(name, index, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling downloadImageDefaultFormat.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new Error('The required parameter "index" was null or undefined when calling downloadImageDefaultFormat.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/images/{index}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "index", objectSerializer_1.ObjectSerializer.toString(index));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get image binary data.
     * @param document Document data.
     * @param index Image index.
     * @param password Document password.
     */
    downloadImageDefaultFormatOnline(document, index, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling downloadImageDefaultFormatOnline.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new Error('The required parameter "index" was null or undefined when calling downloadImageDefaultFormatOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/images/{index}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "index", objectSerializer_1.ObjectSerializer.toString(index));
            const queryParameters = {};
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get image in specified format.
     * @param document Document data.
     * @param index Image index.
     * @param format Export format (png, jpg, gif).
     * @param password Document password.
     */
    downloadImageOnline(document, index, format, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling downloadImageOnline.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new Error('The required parameter "index" was null or undefined when calling downloadImageOnline.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling downloadImageOnline.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ImageExportFormat).filter(i => model.ImageExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ImageExportFormat).map(key => model.ImageExportFormat[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/images/{index}/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "index", objectSerializer_1.ObjectSerializer.toString(index));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get all presentation images in specified format.
     * @param name
     * @param format Export format (png, jpg, gif).
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    downloadImages(name, format, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling downloadImages.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling downloadImages.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ImageExportFormat).filter(i => model.ImageExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ImageExportFormat).map(key => model.ImageExportFormat[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/images/download/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get all presentation images.
     * @param name
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    downloadImagesDefaultFormat(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling downloadImagesDefaultFormat.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/images/download";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get all presentation images.
     * @param document Document data.
     * @param password Document password.
     */
    downloadImagesDefaultFormatOnline(document, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling downloadImagesDefaultFormatOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/images/download";
            const queryParameters = {};
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get all presentation images in specified format.
     * @param document Document data.
     * @param format Export format (png, jpg, gif).
     * @param password Document password.
     */
    downloadImagesOnline(document, format, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling downloadImagesOnline.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling downloadImagesOnline.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ImageExportFormat).filter(i => model.ImageExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ImageExportFormat).map(key => model.ImageExportFormat[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/images/download/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Convert Mathematical Text to MathML Format
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param portionIndex Portion index.
     * @param format Format.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    downloadMathPortion(name, slideIndex, shapeIndex, paragraphIndex, portionIndex, format, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling downloadMathPortion.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling downloadMathPortion.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling downloadMathPortion.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling downloadMathPortion.');
            }
            // verify required parameter 'portionIndex' is not null or undefined
            if (portionIndex === null || portionIndex === undefined) {
                throw new Error('The required parameter "portionIndex" was null or undefined when calling downloadMathPortion.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling downloadMathPortion.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.MathFormat).filter(i => model.MathFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.MathFormat).map(key => model.MathFormat[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}/portions/{portionIndex}/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "portionIndex", objectSerializer_1.ObjectSerializer.toString(portionIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Convert notes slide to the specified image format.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param format Output file format.
     * @param width The width of the slide representation in the output format.
     * @param height The height of the slide representation in the output format
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param fontsFolder Storage folder containing custom fonts to be used with the document.
     */
    downloadNotesSlide(name, slideIndex, format, width = null, height = null, password = null, folder = null, storage = null, fontsFolder = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling downloadNotesSlide.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling downloadNotesSlide.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling downloadNotesSlide.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.NotesSlideExportFormat).filter(i => model.NotesSlideExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.NotesSlideExportFormat).map(key => model.NotesSlideExportFormat[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/notesSlide/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "width", width);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "height", height);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Convert notes slide to the specified image format.
     * @param document Document data.
     * @param slideIndex Slide index.
     * @param format Output file format.
     * @param width The width of the slide representation in the output format.
     * @param height The height of the slide representation in the output format.
     * @param password Document password.
     * @param fontsFolder Storage folder containing custom fonts to be used with the document.
     */
    downloadNotesSlideOnline(document, slideIndex, format, width = null, height = null, password = null, fontsFolder = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling downloadNotesSlideOnline.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling downloadNotesSlideOnline.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling downloadNotesSlideOnline.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.NotesSlideExportFormat).filter(i => model.NotesSlideExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.NotesSlideExportFormat).map(key => model.NotesSlideExportFormat[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/slides/{slideIndex}/notesSlide/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "width", width);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "height", height);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Save a presentation to a specified format.
     * @param name Document name.
     * @param format Export format.
     * @param options Export options.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param fontsFolder Custom fonts folder.
     * @param slides The indices of the slides to be saved. If not specified, all slides are saved by default.
     */
    downloadPresentation(name, format, options = null, password = null, folder = null, storage = null, fontsFolder = null, slides = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling downloadPresentation.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling downloadPresentation.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ExportFormat).filter(i => model.ExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ExportFormat).map(key => model.ExportFormat[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "slides", slides);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: options,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Render shape to specified picture format.
     * @param name Presentation name.
     * @param slideIndex Slide index.
     * @param shapeIndex Index of shape starting from 1
     * @param format Export picture format.
     * @param options export options
     * @param scaleX X scale ratio.
     * @param scaleY Y scale ratio.
     * @param bounds Shape thumbnail bounds type.
     * @param password Document password.
     * @param folder Presentation folder.
     * @param storage Presentation storage.
     * @param fontsFolder Fonts folder.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    downloadShape(name, slideIndex, shapeIndex, format, options = null, scaleX = null, scaleY = null, bounds = null, password = null, folder = null, storage = null, fontsFolder = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling downloadShape.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling downloadShape.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling downloadShape.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling downloadShape.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ShapeExportFormat).filter(i => model.ShapeExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ShapeExportFormat).map(key => model.ShapeExportFormat[key]).join());
            }
            // verify value of enum parameter 'bounds' is valid
            if (bounds != null && bounds != undefined && !Object.keys(model.ShapeThumbnailBounds).filter(i => model.ShapeThumbnailBounds[i].toLowerCase() == bounds.toString().toLowerCase()).length) {
                throw new Error('Invalid value for bounds: ' + bounds + '. Must be one of the following: ' + Object.keys(model.ShapeThumbnailBounds).map(key => model.ShapeThumbnailBounds[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "scaleX", scaleX);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "scaleY", scaleY);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "bounds", bounds);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: options,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Creates the shape from the DTO and returns the result in the specified format.
     * @param format Export format
     * @param dto Shape DTO.
     */
    downloadShapeFromDto(format, dto) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling downloadShapeFromDto.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ShapeExportFormat).filter(i => model.ShapeExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ShapeExportFormat).map(key => model.ShapeExportFormat[key]).join());
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling downloadShapeFromDto.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/shape/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            const requestOptions = {
                method: "POST",
                url: localVarPath,
                data: dto,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Render shape to specified picture format.
     * @param document Document data.
     * @param slideIndex Slide index.
     * @param shapeIndex Index of shape starting from 1
     * @param format Export picture format.
     * @param scaleX X scale ratio.
     * @param scaleY Y scale ratio.
     * @param bounds Shape thumbnail bounds type.
     * @param password Document password.
     * @param storage Document storage.
     * @param fontsFolder Fonts folder.
     * @param options Export options.
     */
    downloadShapeOnline(document, slideIndex, shapeIndex, format, scaleX = null, scaleY = null, bounds = null, password = null, storage = null, fontsFolder = null, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling downloadShapeOnline.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling downloadShapeOnline.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling downloadShapeOnline.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling downloadShapeOnline.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ShapeExportFormat).filter(i => model.ShapeExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ShapeExportFormat).map(key => model.ShapeExportFormat[key]).join());
            }
            // verify value of enum parameter 'bounds' is valid
            if (bounds != null && bounds != undefined && !Object.keys(model.ShapeThumbnailBounds).filter(i => model.ShapeThumbnailBounds[i].toLowerCase() == bounds.toString().toLowerCase()).length) {
                throw new Error('Invalid value for bounds: ' + bounds + '. Must be one of the following: ' + Object.keys(model.ShapeThumbnailBounds).map(key => model.ShapeThumbnailBounds[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/slides/{slideIndex}/shapes/{shapeIndex}/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "scaleX", scaleX);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "scaleY", scaleY);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "bounds", bounds);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: options,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Save a slide to a specified format.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param format Output file format.
     * @param options Export options.
     * @param width The width of the slide representation in the output format; 0 to not adjust the size. Default is 0.
     * @param height The height of the slide representation in the output format; 0 to not adjust the size. Default is 0.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param fontsFolder Storage folder containing custom fonts to be used with the document.
     */
    downloadSlide(name, slideIndex, format, options = null, width = null, height = null, password = null, folder = null, storage = null, fontsFolder = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling downloadSlide.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling downloadSlide.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling downloadSlide.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.SlideExportFormat).filter(i => model.SlideExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.SlideExportFormat).map(key => model.SlideExportFormat[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "width", width);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "height", height);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: options,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Save a slide to a specified format.
     * @param document Document data.
     * @param slideIndex Slide index.
     * @param format Output file format.
     * @param width The width of the slide representation in the output format; 0 to not adjust the size. Default is 0.
     * @param height The height of the slide representation in the output format; 0 to not adjust the size. Default is 0.
     * @param password Document password.
     * @param storage Document storage.
     * @param fontsFolder Storage folder containing custom fonts to be used with the document.
     * @param options Export options.
     */
    downloadSlideOnline(document, slideIndex, format, width = null, height = null, password = null, storage = null, fontsFolder = null, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling downloadSlideOnline.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling downloadSlideOnline.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling downloadSlideOnline.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.SlideExportFormat).filter(i => model.SlideExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.SlideExportFormat).map(key => model.SlideExportFormat[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/slides/{slideIndex}/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "width", width);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "height", height);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: options,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Render shape to specified picture format.
     * @param name Presentation name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapeIndex Index of shape starting from 1
     * @param format Export picture format.
     * @param options Export options
     * @param scaleX X scale ratio.
     * @param scaleY Y scale ratio.
     * @param bounds Shape thumbnail bounds type.
     * @param password Document password.
     * @param folder Presentation folder.
     * @param storage Presentation storage.
     * @param fontsFolder Fonts folder.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    downloadSpecialSlideShape(name, slideIndex, slideType, shapeIndex, format, options = null, scaleX = null, scaleY = null, bounds = null, password = null, folder = null, storage = null, fontsFolder = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling downloadSpecialSlideShape.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling downloadSpecialSlideShape.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling downloadSpecialSlideShape.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling downloadSpecialSlideShape.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling downloadSpecialSlideShape.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ShapeExportFormat).filter(i => model.ShapeExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ShapeExportFormat).map(key => model.ShapeExportFormat[key]).join());
            }
            // verify value of enum parameter 'bounds' is valid
            if (bounds != null && bounds != undefined && !Object.keys(model.ShapeThumbnailBounds).filter(i => model.ShapeThumbnailBounds[i].toLowerCase() == bounds.toString().toLowerCase()).length) {
                throw new Error('Invalid value for bounds: ' + bounds + '. Must be one of the following: ' + Object.keys(model.ShapeThumbnailBounds).map(key => model.ShapeThumbnailBounds[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes/{shapeIndex}/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "scaleX", scaleX);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "scaleY", scaleY);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "bounds", bounds);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: options,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read slide animation effects.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index. If specified, only effects related to that shape are returned.
     * @param paragraphIndex Paragraph index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getAnimation(name, slideIndex, shapeIndex = null, paragraphIndex = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getAnimation.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getAnimation.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/animation";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "shapeIndex", shapeIndex);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "paragraphIndex", paragraphIndex);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get API info.
     */
    getApiInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/info";
            const queryParameters = {};
            const requestOptions = {
                method: "GET",
                url: localVarPath,
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "ApiInfo");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Returns presentation fonts info.
     * @param fontsFolder Storage folder for custom fonts.
     * @param storage Storage for custom fonts.
     */
    getAvailableFonts(fontsFolder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/fonts/available";
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                url: localVarPath,
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "FontsData");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read slide background info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getBackground(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getBackground.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getBackground.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/background";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideBackground");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read slide theme color scheme info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getColorScheme(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getColorScheme.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getColorScheme.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/theme/colorScheme";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "ColorScheme");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Lists comment authors.
     * @param name Document name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getCommentAuthors(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getCommentAuthors.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/comments/authors";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "CommentAuthors");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get disc usage
     * @param storageName Storage name
     */
    getDiscUsage(storageName = null) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/storage/disc";
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storageName", storageName);
            const requestOptions = {
                method: "GET",
                url: localVarPath,
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "DiscUsage");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read presentation document properties.
     * @param name Document name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getDocumentProperties(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getDocumentProperties.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/documentproperties";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "DocumentProperties");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read presentation document property.
     * @param name Document name.
     * @param propertyName The property name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getDocumentProperty(name, propertyName, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getDocumentProperty.');
            }
            // verify required parameter 'propertyName' is not null or undefined
            if (propertyName === null || propertyName === undefined) {
                throw new Error('The required parameter "propertyName" was null or undefined when calling getDocumentProperty.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/documentproperties/{propertyName}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "propertyName", objectSerializer_1.ObjectSerializer.toString(propertyName));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "DocumentProperty");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get file versions
     * @param path File path e.g. '/file.ext'
     * @param storageName Storage name
     */
    getFileVersions(path = null, storageName = null) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/storage/version/{path}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "path", objectSerializer_1.ObjectSerializer.toString(path));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storageName", storageName);
            const requestOptions = {
                method: "GET",
                url: localVarPath,
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "FileVersions");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get all files and folders within a folder
     * @param path Folder path e.g. '/folder'
     * @param storageName Storage name
     */
    getFilesList(path = null, storageName = null) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/storage/folder/{path}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "path", objectSerializer_1.ObjectSerializer.toString(path));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storageName", storageName);
            const requestOptions = {
                method: "GET",
                url: localVarPath,
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "FilesList");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read slide theme font scheme info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getFontScheme(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getFontScheme.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getFontScheme.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/theme/fontScheme";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "FontScheme");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Returns presentation fonts info.
     * @param name Document name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getFonts(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getFonts.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/fonts";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "FontsData");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Returns presentation fonts info.
     * @param document Document data.
     * @param password Document password.
     */
    getFontsOnline(document, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling getFontsOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/fonts";
            const queryParameters = {};
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "FontsData");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read slide theme format scheme info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getFormatScheme(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getFormatScheme.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getFormatScheme.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/theme/formatScheme";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "FormatScheme");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get default templates for HTML5 export.
     */
    getHtml5Templates() {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/html5Templates";
            const queryParameters = {};
            const requestOptions = {
                method: "GET",
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read presentation layoutSlide info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getLayoutSlide(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getLayoutSlide.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getLayoutSlide.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/layoutSlides/{slideIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "LayoutSlide");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read presentation layoutSlides info.
     * @param name Document name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getLayoutSlides(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getLayoutSlides.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/layoutSlides";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "LayoutSlides");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read presentation masterSlide info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getMasterSlide(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getMasterSlide.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getMasterSlide.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/masterSlides/{slideIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "MasterSlide");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read presentation masterSlides info.
     * @param name Document name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getMasterSlides(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getMasterSlides.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/masterSlides";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "MasterSlides");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read notes slide info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getNotesSlide(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getNotesSlide.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getNotesSlide.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/notesSlide";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "NotesSlide");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get header/footer info for the notes slide.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getNotesSlideHeaderFooter(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getNotesSlideHeaderFooter.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getNotesSlideHeaderFooter.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/notesSlide/headerFooter";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "NotesSlideHeaderFooter");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read notes slide info.
     * @param document Document data.
     * @param slideIndex Slide index.
     * @param password Document password.
     */
    getNotesSlideOnline(document, slideIndex, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling getNotesSlideOnline.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getNotesSlideOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/slides/{slideIndex}/notesSlide";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "NotesSlide");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read shape paragraph info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    getParagraph(name, slideIndex, shapeIndex, paragraphIndex, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getParagraph.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getParagraph.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getParagraph.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling getParagraph.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Paragraph");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read effective paragraph info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    getParagraphEffective(name, slideIndex, shapeIndex, paragraphIndex, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getParagraphEffective.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getParagraphEffective.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getParagraphEffective.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling getParagraphEffective.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}/effective";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Paragraph");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Return coordinates of rect that bounds paragraph. The rect includes all the lines of text in paragraph, including empty ones.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getParagraphRectangle(name, slideIndex, shapeIndex, paragraphIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getParagraphRectangle.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getParagraphRectangle.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getParagraphRectangle.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling getParagraphRectangle.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}/bounds";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "TextBounds");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read shape paragraphs info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    getParagraphs(name, slideIndex, shapeIndex, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getParagraphs.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getParagraphs.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getParagraphs.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/paragraphs";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Paragraphs");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read slide placeholder info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param placeholderIndex Placeholder index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getPlaceholder(name, slideIndex, placeholderIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getPlaceholder.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getPlaceholder.');
            }
            // verify required parameter 'placeholderIndex' is not null or undefined
            if (placeholderIndex === null || placeholderIndex === undefined) {
                throw new Error('The required parameter "placeholderIndex" was null or undefined when calling getPlaceholder.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/placeholders/{placeholderIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "placeholderIndex", objectSerializer_1.ObjectSerializer.toString(placeholderIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Placeholder");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read slide placeholders info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getPlaceholders(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getPlaceholders.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getPlaceholders.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/placeholders";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Placeholders");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read paragraph portion info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param portionIndex Portion index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    getPortion(name, slideIndex, shapeIndex, paragraphIndex, portionIndex, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getPortion.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getPortion.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getPortion.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling getPortion.');
            }
            // verify required parameter 'portionIndex' is not null or undefined
            if (portionIndex === null || portionIndex === undefined) {
                throw new Error('The required parameter "portionIndex" was null or undefined when calling getPortion.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}/portions/{portionIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "portionIndex", objectSerializer_1.ObjectSerializer.toString(portionIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Portion");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read effective portion info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param portionIndex Portion index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    getPortionEffective(name, slideIndex, shapeIndex, paragraphIndex, portionIndex, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getPortionEffective.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getPortionEffective.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getPortionEffective.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling getPortionEffective.');
            }
            // verify required parameter 'portionIndex' is not null or undefined
            if (portionIndex === null || portionIndex === undefined) {
                throw new Error('The required parameter "portionIndex" was null or undefined when calling getPortionEffective.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}/portions/{portionIndex}/effective";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "portionIndex", objectSerializer_1.ObjectSerializer.toString(portionIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Portion");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Return coordinates of rect that bounds paragraph. The rect includes all the lines of text in paragraph, including empty ones.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param portionIndex Portion index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getPortionRectangle(name, slideIndex, shapeIndex, paragraphIndex, portionIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getPortionRectangle.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getPortionRectangle.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getPortionRectangle.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling getPortionRectangle.');
            }
            // verify required parameter 'portionIndex' is not null or undefined
            if (portionIndex === null || portionIndex === undefined) {
                throw new Error('The required parameter "portionIndex" was null or undefined when calling getPortionRectangle.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}/portions/{portionIndex}/bounds";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "portionIndex", objectSerializer_1.ObjectSerializer.toString(portionIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "TextBounds");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read paragraph portions info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    getPortions(name, slideIndex, shapeIndex, paragraphIndex, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getPortions.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getPortions.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getPortions.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling getPortions.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}/portions";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Portions");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read presentation info.
     * @param name Document name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getPresentation(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getPresentation.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Document");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read presentation images info.
     * @param name Document name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getPresentationImages(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getPresentationImages.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/images";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Images");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Extract presentation text items.
     * @param name Document name.
     * @param withEmpty True to incude empty items.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getPresentationTextItems(name, withEmpty = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getPresentationTextItems.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/textItems";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "withEmpty", withEmpty);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "TextItems");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read presentation protection properties.
     * @param name Document name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getProtectionProperties(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getProtectionProperties.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/protection";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "ProtectionProperties");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read presentation sections info.
     * @param name Document name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getSections(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getSections.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/sections";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Sections");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read slide shape info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    getShape(name, slideIndex, shapeIndex, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getShape.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getShape.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getShape.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "ShapeBase");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Returns geometry path of the shape
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getShapeGeometryPath(name, slideIndex, shapeIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getShapeGeometryPath.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getShapeGeometryPath.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getShapeGeometryPath.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/geometryPath";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "GeometryPaths");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read slide shapes info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param shapeType Shape type.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    getShapes(name, slideIndex, password = null, folder = null, storage = null, shapeType = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getShapes.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getShapes.');
            }
            // verify value of enum parameter 'shapeType' is valid
            if (shapeType != null && shapeType != undefined && !Object.keys(model.ShapeType).filter(i => model.ShapeType[i].toLowerCase() == shapeType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for shapeType: ' + shapeType + '. Must be one of the following: ' + Object.keys(model.ShapeType).map(key => model.ShapeType[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "shapeType", shapeType);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Shapes");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read presentation slide info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getSlide(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getSlide.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getSlide.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Slide");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read presentation slide comments.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getSlideComments(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getSlideComments.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getSlideComments.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/comments";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideComments");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get footer info for the slide.
     * @param name Document name.
     * @param slideIndex The position of the slide to be reordered.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getSlideHeaderFooter(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getSlideHeaderFooter.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getSlideHeaderFooter.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/headerFooter";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "HeaderFooter");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read slide images info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getSlideImages(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getSlideImages.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getSlideImages.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/images";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Images");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read presentation slide properties.
     * @param name Document name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getSlideProperties(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getSlideProperties.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slideProperties";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideProperties");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read presentation slide show properties.
     * @param name Document name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getSlideShowProperties(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getSlideShowProperties.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slideShowProperties";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideShowProperties");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Extract slide text items.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param withEmpty True to include empty items.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getSlideTextItems(name, slideIndex, withEmpty = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getSlideTextItems.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getSlideTextItems.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/textItems";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "withEmpty", withEmpty);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "TextItems");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read presentation slides info.
     * @param name Document name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getSlides(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getSlides.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Slides");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read special slide (master, layout, notes) animation effects.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapeIndex Shape index. If specified, only effects related to that shape are returned.
     * @param paragraphIndex Paragraph index. If specified, only effects related to that paragraph are returned.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getSpecialSlideAnimation(name, slideIndex, slideType, shapeIndex = null, paragraphIndex = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getSpecialSlideAnimation.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getSpecialSlideAnimation.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling getSpecialSlideAnimation.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/animation";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "shapeIndex", shapeIndex);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "paragraphIndex", paragraphIndex);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read shape paragraph info.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    getSpecialSlideParagraph(name, slideIndex, slideType, shapeIndex, paragraphIndex, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getSpecialSlideParagraph.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getSpecialSlideParagraph.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling getSpecialSlideParagraph.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getSpecialSlideParagraph.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling getSpecialSlideParagraph.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Paragraph");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read special shape paragraphs info.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapeIndex Shape index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    getSpecialSlideParagraphs(name, slideIndex, slideType, shapeIndex, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getSpecialSlideParagraphs.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getSpecialSlideParagraphs.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling getSpecialSlideParagraphs.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getSpecialSlideParagraphs.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes/{shapeIndex}/paragraphs";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Paragraphs");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read paragraph portion info.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param portionIndex Portion index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    getSpecialSlidePortion(name, slideIndex, slideType, shapeIndex, paragraphIndex, portionIndex, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getSpecialSlidePortion.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getSpecialSlidePortion.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling getSpecialSlidePortion.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getSpecialSlidePortion.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling getSpecialSlidePortion.');
            }
            // verify required parameter 'portionIndex' is not null or undefined
            if (portionIndex === null || portionIndex === undefined) {
                throw new Error('The required parameter "portionIndex" was null or undefined when calling getSpecialSlidePortion.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}/portions/{portionIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "portionIndex", objectSerializer_1.ObjectSerializer.toString(portionIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Portion");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read paragraph portions info.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    getSpecialSlidePortions(name, slideIndex, slideType, shapeIndex, paragraphIndex, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getSpecialSlidePortions.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getSpecialSlidePortions.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling getSpecialSlidePortions.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getSpecialSlidePortions.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling getSpecialSlidePortions.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}/portions";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Portions");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read special slide shape info.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapeIndex Shape index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    getSpecialSlideShape(name, slideIndex, slideType, shapeIndex, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getSpecialSlideShape.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getSpecialSlideShape.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling getSpecialSlideShape.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getSpecialSlideShape.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes/{shapeIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "ShapeBase");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read special slide shapes info.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    getSpecialSlideShapes(name, slideIndex, slideType, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getSpecialSlideShapes.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getSpecialSlideShapes.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling getSpecialSlideShapes.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Shapes");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Returns paragraph info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param rowIndex Row index.
     * @param cellIndex Table cell index.
     * @param paragraphIndex Paragraph index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getTableCellParagraph(name, slideIndex, shapeIndex, rowIndex, cellIndex, paragraphIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getTableCellParagraph.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getTableCellParagraph.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getTableCellParagraph.');
            }
            // verify required parameter 'rowIndex' is not null or undefined
            if (rowIndex === null || rowIndex === undefined) {
                throw new Error('The required parameter "rowIndex" was null or undefined when calling getTableCellParagraph.');
            }
            // verify required parameter 'cellIndex' is not null or undefined
            if (cellIndex === null || cellIndex === undefined) {
                throw new Error('The required parameter "cellIndex" was null or undefined when calling getTableCellParagraph.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling getTableCellParagraph.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/rows/{rowIndex}/cells/{cellIndex}/paragraphs/{paragraphIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "rowIndex", objectSerializer_1.ObjectSerializer.toString(rowIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "cellIndex", objectSerializer_1.ObjectSerializer.toString(cellIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Paragraph");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Returns table cell paragraphs.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param rowIndex Row index.
     * @param cellIndex Table cell index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getTableCellParagraphs(name, slideIndex, shapeIndex, rowIndex, cellIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getTableCellParagraphs.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getTableCellParagraphs.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getTableCellParagraphs.');
            }
            // verify required parameter 'rowIndex' is not null or undefined
            if (rowIndex === null || rowIndex === undefined) {
                throw new Error('The required parameter "rowIndex" was null or undefined when calling getTableCellParagraphs.');
            }
            // verify required parameter 'cellIndex' is not null or undefined
            if (cellIndex === null || cellIndex === undefined) {
                throw new Error('The required parameter "cellIndex" was null or undefined when calling getTableCellParagraphs.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/rows/{rowIndex}/cells/{cellIndex}/paragraphs";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "rowIndex", objectSerializer_1.ObjectSerializer.toString(rowIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "cellIndex", objectSerializer_1.ObjectSerializer.toString(cellIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Paragraphs");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Returns table cell portion.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param rowIndex Row index.
     * @param cellIndex Table cell index.
     * @param paragraphIndex Paragraph index.
     * @param portionIndex Portion index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getTableCellPortion(name, slideIndex, shapeIndex, rowIndex, cellIndex, paragraphIndex, portionIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getTableCellPortion.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getTableCellPortion.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getTableCellPortion.');
            }
            // verify required parameter 'rowIndex' is not null or undefined
            if (rowIndex === null || rowIndex === undefined) {
                throw new Error('The required parameter "rowIndex" was null or undefined when calling getTableCellPortion.');
            }
            // verify required parameter 'cellIndex' is not null or undefined
            if (cellIndex === null || cellIndex === undefined) {
                throw new Error('The required parameter "cellIndex" was null or undefined when calling getTableCellPortion.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling getTableCellPortion.');
            }
            // verify required parameter 'portionIndex' is not null or undefined
            if (portionIndex === null || portionIndex === undefined) {
                throw new Error('The required parameter "portionIndex" was null or undefined when calling getTableCellPortion.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/rows/{rowIndex}/cells/{cellIndex}/paragraphs/{paragraphIndex}/portions/{portionIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "rowIndex", objectSerializer_1.ObjectSerializer.toString(rowIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "cellIndex", objectSerializer_1.ObjectSerializer.toString(cellIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "portionIndex", objectSerializer_1.ObjectSerializer.toString(portionIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Portion");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Returns table cell portions.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param rowIndex Row index.
     * @param cellIndex Table cell index.
     * @param paragraphIndex Paragraph index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getTableCellPortions(name, slideIndex, shapeIndex, rowIndex, cellIndex, paragraphIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getTableCellPortions.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getTableCellPortions.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling getTableCellPortions.');
            }
            // verify required parameter 'rowIndex' is not null or undefined
            if (rowIndex === null || rowIndex === undefined) {
                throw new Error('The required parameter "rowIndex" was null or undefined when calling getTableCellPortions.');
            }
            // verify required parameter 'cellIndex' is not null or undefined
            if (cellIndex === null || cellIndex === undefined) {
                throw new Error('The required parameter "cellIndex" was null or undefined when calling getTableCellPortions.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling getTableCellPortions.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/rows/{rowIndex}/cells/{cellIndex}/paragraphs/{paragraphIndex}/portions";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "rowIndex", objectSerializer_1.ObjectSerializer.toString(rowIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "cellIndex", objectSerializer_1.ObjectSerializer.toString(cellIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Portions");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read slide theme info.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getTheme(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getTheme.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling getTheme.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/theme";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Theme");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get VBA module info.
     * @param name Document name.
     * @param moduleIndex The index of the macros module to remove.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getVbaModule(name, moduleIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getVbaModule.');
            }
            // verify required parameter 'moduleIndex' is not null or undefined
            if (moduleIndex === null || moduleIndex === undefined) {
                throw new Error('The required parameter "moduleIndex" was null or undefined when calling getVbaModule.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/vbaProject/modules/{moduleIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "moduleIndex", objectSerializer_1.ObjectSerializer.toString(moduleIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "VbaModule");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get VBA project info.
     * @param name Document name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getVbaProject(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getVbaProject.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/vbaProject";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "VbaProject");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Read presentation view properties.
     * @param name Document name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    getViewProperties(name, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling getViewProperties.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/viewProperties";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "ViewProperties");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Highlight all matches of sample in text frame text using specified color.
     * @param name Document name.
     * @param regex Regular expression.
     * @param color Highlighting color.
     * @param ignoreCase True to search ignoring char case.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    highlightPresentationRegex(name, regex, color, ignoreCase = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling highlightPresentationRegex.');
            }
            // verify required parameter 'regex' is not null or undefined
            if (regex === null || regex === undefined) {
                throw new Error('The required parameter "regex" was null or undefined when calling highlightPresentationRegex.');
            }
            // verify required parameter 'color' is not null or undefined
            if (color === null || color === undefined) {
                throw new Error('The required parameter "color" was null or undefined when calling highlightPresentationRegex.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/highlightRegex";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "regex", regex);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "color", color);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "ignoreCase", ignoreCase);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "DocumentReplaceResult");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Highlight all matches of sample using specified color.
     * @param name Document name.
     * @param text Text sample to highlight.
     * @param color Highlighting color.
     * @param wholeWordsOnly Match only whole words.
     * @param ignoreCase True to search ignoring char case.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    highlightPresentationText(name, text, color, wholeWordsOnly = null, ignoreCase = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling highlightPresentationText.');
            }
            // verify required parameter 'text' is not null or undefined
            if (text === null || text === undefined) {
                throw new Error('The required parameter "text" was null or undefined when calling highlightPresentationText.');
            }
            // verify required parameter 'color' is not null or undefined
            if (color === null || color === undefined) {
                throw new Error('The required parameter "color" was null or undefined when calling highlightPresentationText.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/highlightText";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "text", text);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "color", color);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "wholeWordsOnly", wholeWordsOnly);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "ignoreCase", ignoreCase);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "DocumentReplaceResult");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Highlight all matches of sample in text frame text using specified color.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param regex Regular expression.
     * @param color Highlighting color.
     * @param ignoreCase True to search ignoring char case.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    highlightShapeRegex(name, slideIndex, shapeIndex, regex, color, ignoreCase = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling highlightShapeRegex.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling highlightShapeRegex.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling highlightShapeRegex.');
            }
            // verify required parameter 'regex' is not null or undefined
            if (regex === null || regex === undefined) {
                throw new Error('The required parameter "regex" was null or undefined when calling highlightShapeRegex.');
            }
            // verify required parameter 'color' is not null or undefined
            if (color === null || color === undefined) {
                throw new Error('The required parameter "color" was null or undefined when calling highlightShapeRegex.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/highlightRegex";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "regex", regex);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "color", color);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "ignoreCase", ignoreCase);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Shape");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Highlight all matches of sample in text frame text using specified color.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param text Text sample to highlight.
     * @param color Highlighting color.
     * @param wholeWordsOnly Match only whole words.
     * @param ignoreCase True to search ignoring char case.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    highlightShapeText(name, slideIndex, shapeIndex, text, color, wholeWordsOnly = null, ignoreCase = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling highlightShapeText.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling highlightShapeText.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling highlightShapeText.');
            }
            // verify required parameter 'text' is not null or undefined
            if (text === null || text === undefined) {
                throw new Error('The required parameter "text" was null or undefined when calling highlightShapeText.');
            }
            // verify required parameter 'color' is not null or undefined
            if (color === null || color === undefined) {
                throw new Error('The required parameter "color" was null or undefined when calling highlightShapeText.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/highlightText";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "text", text);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "color", color);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "wholeWordsOnly", wholeWordsOnly);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "ignoreCase", ignoreCase);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Shape");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Create presentation document from html.
     * @param name Document name.
     * @param html HTML data.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    importFromHtml(name, html = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling importFromHtml.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/fromHtml";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: html,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "Content-type", "text/plain");
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Document");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Create presentation document from pdf or append pdf to an existing presentation.
     * @param name Document name.
     * @param pdf PDF data.
     * @param options Import options.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    importFromPdf(name, pdf, options = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling importFromPdf.');
            }
            // verify required parameter 'pdf' is not null or undefined
            if (pdf === null || pdf === undefined) {
                throw new Error('The required parameter "pdf" was null or undefined when calling importFromPdf.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/fromPdf";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: options,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (pdf != null) {
                localVarFiles.push(pdf);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Document");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Imports shapes from SVG file.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param image SVG image data.
     * @param x The X coordinate of the imported group of shapes (0 is default if not specified).
     * @param y The Y coordinate of the imported group of shapes (0 is default if not specified).
     * @param width The width of the imported group of shapes (default is SVG image width).
     * @param height The height of the imported group of shapes (default is SVG image width).
     * @param shapes Indexes of shapes to import. All shapes are imported if not specified.
     * @param group If true, the set of shapes will be imported as a one group shape.
     * @param password Document password.
     * @param folder Presentation folder.
     * @param storage Presentation storage.
     */
    importShapesFromSvg(name, slideIndex, image = null, x = null, y = null, width = null, height = null, shapes = null, group = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling importShapesFromSvg.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling importShapesFromSvg.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/fromSvg";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "x", x);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "y", y);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "width", width);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "height", height);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "shapes", shapes);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "group", group);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (image != null) {
                localVarFiles.push(image);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Shapes");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Merge the presentation with other presentations specified in the request parameter.
     * @param name Document name.
     * @param request PresentationsMergeRequest with a list of presentations to merge.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    merge(name, request, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling merge.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new Error('The required parameter "request" was null or undefined when calling merge.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/merge";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: request,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Document");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Merges presentations or some of their slides specified in the request parameter. Result will be save in the storage.
     * @param outPath Path to save result.
     * @param files Files to merge
     * @param request Merge request.
     * @param storage Document storage.
     */
    mergeAndSaveOnline(outPath, files = null, request = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'outPath' is not null or undefined
            if (outPath === null || outPath === undefined) {
                throw new Error('The required parameter "outPath" was null or undefined when calling mergeAndSaveOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/merge";
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "outPath", outPath);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                url: localVarPath,
                data: request,
                params: queryParameters
            };
            let localVarFiles = [];
            if (files != null) {
                localVarFiles = localVarFiles.concat(files);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Merges presentations or some of their slides specified in the request parameter. Returns result file in the response.
     * @param files Files to merge
     * @param request Merge request.
     * @param storage Document storage.
     */
    mergeOnline(files = null, request = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/merge";
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                url: localVarPath,
                data: request,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            let localVarFiles = [];
            if (files != null) {
                localVarFiles = localVarFiles.concat(files);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Merge table cells.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param tableCellMergeOptions Merge settings.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    mergeTableCells(name, slideIndex, shapeIndex, tableCellMergeOptions, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling mergeTableCells.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling mergeTableCells.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling mergeTableCells.');
            }
            // verify required parameter 'tableCellMergeOptions' is not null or undefined
            if (tableCellMergeOptions === null || tableCellMergeOptions === undefined) {
                throw new Error('The required parameter "tableCellMergeOptions" was null or undefined when calling mergeTableCells.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/mergeCells";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: tableCellMergeOptions,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Table");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Move file
     * @param srcPath Source file path e.g. '/src.ext'
     * @param destPath Destination file path e.g. '/dest.ext'
     * @param srcStorageName Source storage name
     * @param destStorageName Destination storage name
     * @param versionId File version ID to move
     */
    moveFile(srcPath, destPath, srcStorageName = null, destStorageName = null, versionId = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'srcPath' is not null or undefined
            if (srcPath === null || srcPath === undefined) {
                throw new Error('The required parameter "srcPath" was null or undefined when calling moveFile.');
            }
            // verify required parameter 'destPath' is not null or undefined
            if (destPath === null || destPath === undefined) {
                throw new Error('The required parameter "destPath" was null or undefined when calling moveFile.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/storage/file/move/{srcPath}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "srcPath", objectSerializer_1.ObjectSerializer.toString(srcPath));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destPath", destPath);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "srcStorageName", srcStorageName);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destStorageName", destStorageName);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "versionId", versionId);
            const requestOptions = {
                method: "PUT",
                url: localVarPath,
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Move folder
     * @param srcPath Folder path to move e.g. '/folder'
     * @param destPath Destination folder path to move to e.g '/dst'
     * @param srcStorageName Source storage name
     * @param destStorageName Destination storage name
     */
    moveFolder(srcPath, destPath, srcStorageName = null, destStorageName = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'srcPath' is not null or undefined
            if (srcPath === null || srcPath === undefined) {
                throw new Error('The required parameter "srcPath" was null or undefined when calling moveFolder.');
            }
            // verify required parameter 'destPath' is not null or undefined
            if (destPath === null || destPath === undefined) {
                throw new Error('The required parameter "destPath" was null or undefined when calling moveFolder.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/storage/folder/move/{srcPath}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "srcPath", objectSerializer_1.ObjectSerializer.toString(srcPath));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destPath", destPath);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "srcStorageName", srcStorageName);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destStorageName", destStorageName);
            const requestOptions = {
                method: "PUT",
                url: localVarPath,
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Move presentation section to a specified position.
     * @param name Document name.
     * @param sectionIndex The position of the section to be reordered.
     * @param newPosition The new position of the reordered section.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    moveSection(name, sectionIndex, newPosition, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling moveSection.');
            }
            // verify required parameter 'sectionIndex' is not null or undefined
            if (sectionIndex === null || sectionIndex === undefined) {
                throw new Error('The required parameter "sectionIndex" was null or undefined when calling moveSection.');
            }
            // verify required parameter 'newPosition' is not null or undefined
            if (newPosition === null || newPosition === undefined) {
                throw new Error('The required parameter "newPosition" was null or undefined when calling moveSection.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/sections/{sectionIndex}/move";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "sectionIndex", objectSerializer_1.ObjectSerializer.toString(sectionIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "newPosition", newPosition);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Sections");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Reorder presentation slide position.
     * @param name Document name.
     * @param slideIndex The position of the slide to be reordered.
     * @param newPosition The new position of the reordered slide.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    moveSlide(name, slideIndex, newPosition, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling moveSlide.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling moveSlide.');
            }
            // verify required parameter 'newPosition' is not null or undefined
            if (newPosition === null || newPosition === undefined) {
                throw new Error('The required parameter "newPosition" was null or undefined when calling moveSlide.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/move";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "newPosition", newPosition);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Slides");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get info whether a notes slide exists.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    notesSlideExists(name, slideIndex, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling notesSlideExists.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling notesSlideExists.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/notesSlide/exist";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "GET",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "EntityExists");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Get info whether a notes slide exists.
     * @param document Document data.
     * @param slideIndex Slide index.
     * @param password Document password.
     */
    notesSlideExistsOnline(document, slideIndex, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling notesSlideExistsOnline.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling notesSlideExistsOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/slides/{slideIndex}/notesSlide/exist";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "EntityExists");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Check if file or folder exists
     * @param path File or folder path e.g. '/file.ext' or '/folder'
     * @param storageName Storage name
     * @param versionId File version ID
     */
    objectExists(path = null, storageName = null, versionId = null) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/storage/exist/{path}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "path", objectSerializer_1.ObjectSerializer.toString(path));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storageName", storageName);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "versionId", versionId);
            const requestOptions = {
                method: "GET",
                url: localVarPath,
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "ObjectExist");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Merge the presentation with other presentations or some of their slides specified in the request parameter.
     * @param name Document name.
     * @param request OrderedMergeRequest with a list of presentations and slide indices to merge.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    orderedMerge(name, request, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling orderedMerge.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new Error('The required parameter "request" was null or undefined when calling orderedMerge.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/merge";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: request,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Document");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Performs slides pipeline.
     * @param pipeline A Pipeline object.
     * @param files Files to upload with the pipeline
     */
    pipeline(pipeline, files = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new Error('The required parameter "pipeline" was null or undefined when calling pipeline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/pipeline";
            const queryParameters = {};
            const requestOptions = {
                method: "POST",
                url: localVarPath,
                data: pipeline,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            let localVarFiles = [];
            if (files != null) {
                localVarFiles = localVarFiles.concat(files);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Reorder presentation slides positions.
     * @param name Document name.
     * @param oldPositions A comma separated array of positions of slides to be reordered.
     * @param newPositions A comma separated array of new slide positions.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    reorderSlides(name, oldPositions = null, newPositions = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling reorderSlides.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/reorder";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "oldPositions", oldPositions);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "newPositions", newPositions);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Slides");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Replaces specified font and returns presentation fonts info.
     * @param name Document name.
     * @param sourceFont Source font name.
     * @param targetFont Target font name.
     * @param embed Embed target font.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param fontsFolder Custom fonts folder.
     */
    replaceFont(name, sourceFont, targetFont, embed = null, password = null, folder = null, storage = null, fontsFolder = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling replaceFont.');
            }
            // verify required parameter 'sourceFont' is not null or undefined
            if (sourceFont === null || sourceFont === undefined) {
                throw new Error('The required parameter "sourceFont" was null or undefined when calling replaceFont.');
            }
            // verify required parameter 'targetFont' is not null or undefined
            if (targetFont === null || targetFont === undefined) {
                throw new Error('The required parameter "targetFont" was null or undefined when calling replaceFont.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/fonts/{sourceFont}/replace/{targetFont}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "sourceFont", objectSerializer_1.ObjectSerializer.toString(sourceFont));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "targetFont", objectSerializer_1.ObjectSerializer.toString(targetFont));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "embed", embed);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "FontsData");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Replaces specified font and returns presentation.
     * @param document Document data.
     * @param sourceFont Source font name.
     * @param targetFont Target font name.
     * @param embed Embed target font.
     * @param password Document password.
     * @param fontsFolder Custom fonts folder.
     */
    replaceFontOnline(document, sourceFont, targetFont, embed = null, password = null, fontsFolder = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling replaceFontOnline.');
            }
            // verify required parameter 'sourceFont' is not null or undefined
            if (sourceFont === null || sourceFont === undefined) {
                throw new Error('The required parameter "sourceFont" was null or undefined when calling replaceFontOnline.');
            }
            // verify required parameter 'targetFont' is not null or undefined
            if (targetFont === null || targetFont === undefined) {
                throw new Error('The required parameter "targetFont" was null or undefined when calling replaceFontOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/fonts/{sourceFont}/replace/{targetFont}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "sourceFont", objectSerializer_1.ObjectSerializer.toString(sourceFont));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "targetFont", objectSerializer_1.ObjectSerializer.toString(targetFont));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "embed", embed);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Replaces image by the specified index.
     * @param name Document name.
     * @param imageIndex Image index.
     * @param image Image data.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    replaceImage(name, imageIndex, image, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling replaceImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new Error('The required parameter "imageIndex" was null or undefined when calling replaceImage.');
            }
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new Error('The required parameter "image" was null or undefined when calling replaceImage.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/images/{imageIndex}/replace";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "imageIndex", objectSerializer_1.ObjectSerializer.toString(imageIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (image != null) {
                localVarFiles.push(image);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Replaces image by the specified index and returns updated document.
     * @param document Document data.
     * @param imageIndex Image index.
     * @param image Image data.
     * @param password Password.
     */
    replaceImageOnline(document, imageIndex, image, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling replaceImageOnline.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new Error('The required parameter "imageIndex" was null or undefined when calling replaceImageOnline.');
            }
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new Error('The required parameter "image" was null or undefined when calling replaceImageOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/images/{imageIndex}/replace";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "imageIndex", objectSerializer_1.ObjectSerializer.toString(imageIndex));
            const queryParameters = {};
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            if (image != null) {
                localVarFiles.push(image);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Replace text with a new value using a regex.
     * @param name Document name.
     * @param pattern Text value pattern to be replaced.
     * @param newValue Text value to replace with.
     * @param ignoreCase True if character case must be ignored.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    replacePresentationRegex(name, pattern, newValue, ignoreCase = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling replacePresentationRegex.');
            }
            // verify required parameter 'pattern' is not null or undefined
            if (pattern === null || pattern === undefined) {
                throw new Error('The required parameter "pattern" was null or undefined when calling replacePresentationRegex.');
            }
            // verify required parameter 'newValue' is not null or undefined
            if (newValue === null || newValue === undefined) {
                throw new Error('The required parameter "newValue" was null or undefined when calling replacePresentationRegex.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/replaceRegex";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "pattern", pattern);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "newValue", newValue);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "ignoreCase", ignoreCase);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "DocumentReplaceResult");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Replace text with a new value using a regex.
     * @param document Document data.
     * @param pattern Text regex pattern to be replaced.
     * @param newValue Text value to replace with.
     * @param ignoreCase True if character case must be ignored.
     * @param password Document password.
     */
    replacePresentationRegexOnline(document, pattern, newValue, ignoreCase = null, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling replacePresentationRegexOnline.');
            }
            // verify required parameter 'pattern' is not null or undefined
            if (pattern === null || pattern === undefined) {
                throw new Error('The required parameter "pattern" was null or undefined when calling replacePresentationRegexOnline.');
            }
            // verify required parameter 'newValue' is not null or undefined
            if (newValue === null || newValue === undefined) {
                throw new Error('The required parameter "newValue" was null or undefined when calling replacePresentationRegexOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/replaceRegex";
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "pattern", pattern);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "newValue", newValue);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "ignoreCase", ignoreCase);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Replace text with a new value.
     * @param name Document name.
     * @param oldValue Text value to be replaced.
     * @param newValue Text value to replace with.
     * @param ignoreCase True if character case must be ignored.
     * @param wholeWordsOnly True to replace whole words only.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    replacePresentationText(name, oldValue, newValue, ignoreCase = null, wholeWordsOnly = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling replacePresentationText.');
            }
            // verify required parameter 'oldValue' is not null or undefined
            if (oldValue === null || oldValue === undefined) {
                throw new Error('The required parameter "oldValue" was null or undefined when calling replacePresentationText.');
            }
            // verify required parameter 'newValue' is not null or undefined
            if (newValue === null || newValue === undefined) {
                throw new Error('The required parameter "newValue" was null or undefined when calling replacePresentationText.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/replaceText";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "oldValue", oldValue);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "newValue", newValue);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "ignoreCase", ignoreCase);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "wholeWordsOnly", wholeWordsOnly);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "DocumentReplaceResult");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Replace text with a new value.
     * @param document Document data.
     * @param oldValue Text value to be replaced.
     * @param newValue Text value to replace with.
     * @param ignoreCase True if character case must be ignored.
     * @param wholeWordsOnly True to replace whole words only.
     * @param password Document password.
     */
    replacePresentationTextOnline(document, oldValue, newValue, ignoreCase = null, wholeWordsOnly = null, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling replacePresentationTextOnline.');
            }
            // verify required parameter 'oldValue' is not null or undefined
            if (oldValue === null || oldValue === undefined) {
                throw new Error('The required parameter "oldValue" was null or undefined when calling replacePresentationTextOnline.');
            }
            // verify required parameter 'newValue' is not null or undefined
            if (newValue === null || newValue === undefined) {
                throw new Error('The required parameter "newValue" was null or undefined when calling replacePresentationTextOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/replaceText";
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "oldValue", oldValue);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "newValue", newValue);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "ignoreCase", ignoreCase);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "wholeWordsOnly", wholeWordsOnly);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Replace text with a new value.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param oldValue Text value to be replaced.
     * @param newValue Text value to replace with.
     * @param ignoreCase True if character case must be ignored.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    replaceSlideText(name, slideIndex, oldValue, newValue, ignoreCase = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling replaceSlideText.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling replaceSlideText.');
            }
            // verify required parameter 'oldValue' is not null or undefined
            if (oldValue === null || oldValue === undefined) {
                throw new Error('The required parameter "oldValue" was null or undefined when calling replaceSlideText.');
            }
            // verify required parameter 'newValue' is not null or undefined
            if (newValue === null || newValue === undefined) {
                throw new Error('The required parameter "newValue" was null or undefined when calling replaceSlideText.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/replaceText";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "oldValue", oldValue);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "newValue", newValue);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "ignoreCase", ignoreCase);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideReplaceResult");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Replace slide text with a new value.
     * @param document Document data.
     * @param slideIndex Index of target slide.
     * @param oldValue Text value to be replaced.
     * @param newValue Text value to replace with.
     * @param ignoreCase True if character case must be ignored.
     * @param password Document password.
     */
    replaceSlideTextOnline(document, slideIndex, oldValue, newValue, ignoreCase = null, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling replaceSlideTextOnline.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling replaceSlideTextOnline.');
            }
            // verify required parameter 'oldValue' is not null or undefined
            if (oldValue === null || oldValue === undefined) {
                throw new Error('The required parameter "oldValue" was null or undefined when calling replaceSlideTextOnline.');
            }
            // verify required parameter 'newValue' is not null or undefined
            if (newValue === null || newValue === undefined) {
                throw new Error('The required parameter "newValue" was null or undefined when calling replaceSlideTextOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/slides/{slideIndex}/replaceText";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "oldValue", oldValue);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "newValue", newValue);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "ignoreCase", ignoreCase);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Finds and replaces text in presentation with given format.
     * @param name Document name.
     * @param oldValue Text value to be replaced.
     * @param newValue Text value to replace with.
     * @param portionFormat Portion format.
     * @param withMasters Text replacement includes master slides.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    replaceTextFormatting(name, oldValue, newValue, portionFormat = null, withMasters = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling replaceTextFormatting.');
            }
            // verify required parameter 'oldValue' is not null or undefined
            if (oldValue === null || oldValue === undefined) {
                throw new Error('The required parameter "oldValue" was null or undefined when calling replaceTextFormatting.');
            }
            // verify required parameter 'newValue' is not null or undefined
            if (newValue === null || newValue === undefined) {
                throw new Error('The required parameter "newValue" was null or undefined when calling replaceTextFormatting.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/replaceTextFormatting";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "oldValue", oldValue);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "newValue", newValue);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "withMasters", withMasters);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: portionFormat,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Document");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Finds and replaces text in presentation with given format.
     * @param document Document data.
     * @param oldValue Text value to be replaced.
     * @param newValue Text value to replace with.
     * @param portionFormat Portion format.
     * @param withMasters Text replacement includes master slides.
     * @param password Document password.
     */
    replaceTextFormattingOnline(document, oldValue, newValue, portionFormat = null, withMasters = null, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling replaceTextFormattingOnline.');
            }
            // verify required parameter 'oldValue' is not null or undefined
            if (oldValue === null || oldValue === undefined) {
                throw new Error('The required parameter "oldValue" was null or undefined when calling replaceTextFormattingOnline.');
            }
            // verify required parameter 'newValue' is not null or undefined
            if (newValue === null || newValue === undefined) {
                throw new Error('The required parameter "newValue" was null or undefined when calling replaceTextFormattingOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/replaceTextFormatting";
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "oldValue", oldValue);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "newValue", newValue);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "withMasters", withMasters);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: portionFormat,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Convert Mathematical Text to MathML Format and saves result to the storage
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param portionIndex Portion index.
     * @param format Format.
     * @param outPath Path to save result.
     * @param password Document password.
     * @param folder Presentation folder.
     * @param storage Presentation storage.
     */
    saveMathPortion(name, slideIndex, shapeIndex, paragraphIndex, portionIndex, format, outPath, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling saveMathPortion.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling saveMathPortion.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling saveMathPortion.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling saveMathPortion.');
            }
            // verify required parameter 'portionIndex' is not null or undefined
            if (portionIndex === null || portionIndex === undefined) {
                throw new Error('The required parameter "portionIndex" was null or undefined when calling saveMathPortion.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling saveMathPortion.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.MathFormat).filter(i => model.MathFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.MathFormat).map(key => model.MathFormat[key]).join());
            }
            // verify required parameter 'outPath' is not null or undefined
            if (outPath === null || outPath === undefined) {
                throw new Error('The required parameter "outPath" was null or undefined when calling saveMathPortion.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}/portions/{portionIndex}/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "portionIndex", objectSerializer_1.ObjectSerializer.toString(portionIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "outPath", outPath);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Save a presentation to a specified format.
     * @param name Document name.
     * @param format Export format.
     * @param outPath Output path.
     * @param options Export options.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param fontsFolder Custom fonts folder.
     * @param slides The indices of the slides to be saved. If not specified, all slides are saved by default.
     */
    savePresentation(name, format, outPath, options = null, password = null, folder = null, storage = null, fontsFolder = null, slides = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling savePresentation.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling savePresentation.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ExportFormat).filter(i => model.ExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ExportFormat).map(key => model.ExportFormat[key]).join());
            }
            // verify required parameter 'outPath' is not null or undefined
            if (outPath === null || outPath === undefined) {
                throw new Error('The required parameter "outPath" was null or undefined when calling savePresentation.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "outPath", outPath);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "slides", slides);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: options,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Render shape to specified picture format.
     * @param name Presentation name.
     * @param slideIndex Slide index.
     * @param shapeIndex Index of shape starting from 1
     * @param format Export picture format.
     * @param outPath Output path.
     * @param options export options
     * @param scaleX X scale ratio.
     * @param scaleY Y scale ratio.
     * @param bounds Shape thumbnail bounds type.
     * @param password Document password.
     * @param folder Presentation folder.
     * @param storage Presentation storage.
     * @param fontsFolder Fonts folder.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    saveShape(name, slideIndex, shapeIndex, format, outPath, options = null, scaleX = null, scaleY = null, bounds = null, password = null, folder = null, storage = null, fontsFolder = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling saveShape.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling saveShape.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling saveShape.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling saveShape.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ShapeExportFormat).filter(i => model.ShapeExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ShapeExportFormat).map(key => model.ShapeExportFormat[key]).join());
            }
            // verify required parameter 'outPath' is not null or undefined
            if (outPath === null || outPath === undefined) {
                throw new Error('The required parameter "outPath" was null or undefined when calling saveShape.');
            }
            // verify value of enum parameter 'bounds' is valid
            if (bounds != null && bounds != undefined && !Object.keys(model.ShapeThumbnailBounds).filter(i => model.ShapeThumbnailBounds[i].toLowerCase() == bounds.toString().toLowerCase()).length) {
                throw new Error('Invalid value for bounds: ' + bounds + '. Must be one of the following: ' + Object.keys(model.ShapeThumbnailBounds).map(key => model.ShapeThumbnailBounds[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "outPath", outPath);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "scaleX", scaleX);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "scaleY", scaleY);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "bounds", bounds);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: options,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Render shape to specified picture format.
     * @param document Document data.
     * @param slideIndex Slide index.
     * @param shapeIndex Index of shape starting from 1
     * @param format Export picture format.
     * @param outPath Path to save result.
     * @param scaleX X scale ratio.
     * @param scaleY Y scale ratio.
     * @param bounds Shape thumbnail bounds type.
     * @param password Document password.
     * @param storage Document storage.
     * @param fontsFolder Fonts folder.
     * @param options Export options.
     */
    saveShapeOnline(document, slideIndex, shapeIndex, format, outPath, scaleX = null, scaleY = null, bounds = null, password = null, storage = null, fontsFolder = null, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling saveShapeOnline.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling saveShapeOnline.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling saveShapeOnline.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling saveShapeOnline.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ShapeExportFormat).filter(i => model.ShapeExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ShapeExportFormat).map(key => model.ShapeExportFormat[key]).join());
            }
            // verify required parameter 'outPath' is not null or undefined
            if (outPath === null || outPath === undefined) {
                throw new Error('The required parameter "outPath" was null or undefined when calling saveShapeOnline.');
            }
            // verify value of enum parameter 'bounds' is valid
            if (bounds != null && bounds != undefined && !Object.keys(model.ShapeThumbnailBounds).filter(i => model.ShapeThumbnailBounds[i].toLowerCase() == bounds.toString().toLowerCase()).length) {
                throw new Error('Invalid value for bounds: ' + bounds + '. Must be one of the following: ' + Object.keys(model.ShapeThumbnailBounds).map(key => model.ShapeThumbnailBounds[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/slides/{slideIndex}/shapes/{shapeIndex}/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "outPath", outPath);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "scaleX", scaleX);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "scaleY", scaleY);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "bounds", bounds);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: options,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Save a slide to a specified format.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param format Output file format.
     * @param outPath Path to upload the output file to.
     * @param options Export options.
     * @param width The width of the slide representation in the output format; 0 to not adjust the size. Default is 0.
     * @param height The height of the slide representation in the output format; 0 to not adjust the size. Default is 0.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param fontsFolder Storage folder containing custom fonts to be used with the document.
     */
    saveSlide(name, slideIndex, format, outPath, options = null, width = null, height = null, password = null, folder = null, storage = null, fontsFolder = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling saveSlide.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling saveSlide.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling saveSlide.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.SlideExportFormat).filter(i => model.SlideExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.SlideExportFormat).map(key => model.SlideExportFormat[key]).join());
            }
            // verify required parameter 'outPath' is not null or undefined
            if (outPath === null || outPath === undefined) {
                throw new Error('The required parameter "outPath" was null or undefined when calling saveSlide.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "outPath", outPath);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "width", width);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "height", height);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: options,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Save a slide to a specified format.
     * @param document Document data.
     * @param slideIndex Slide index.
     * @param format Output file format.
     * @param outPath Path to save result.
     * @param width The width of the slide representation in the output format; 0 to not adjust the size. Default is 0.
     * @param height The height of the slide representation in the output format; 0 to not adjust the size. Default is 0.
     * @param password Document password.
     * @param storage Document storage.
     * @param fontsFolder Storage folder containing custom fonts to be used with the document.
     * @param options Export options.
     */
    saveSlideOnline(document, slideIndex, format, outPath, width = null, height = null, password = null, storage = null, fontsFolder = null, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling saveSlideOnline.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling saveSlideOnline.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling saveSlideOnline.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.SlideExportFormat).filter(i => model.SlideExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.SlideExportFormat).map(key => model.SlideExportFormat[key]).join());
            }
            // verify required parameter 'outPath' is not null or undefined
            if (outPath === null || outPath === undefined) {
                throw new Error('The required parameter "outPath" was null or undefined when calling saveSlideOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/slides/{slideIndex}/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "outPath", outPath);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "width", width);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "height", height);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: options,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Render shape to specified picture format.
     * @param name Presentation name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapeIndex Index of shape starting from 1
     * @param format Export picture format.
     * @param outPath Output path.
     * @param options export options
     * @param scaleX X scale ratio.
     * @param scaleY Y scale ratio.
     * @param bounds Shape thumbnail bounds type.
     * @param password Document password.
     * @param folder Presentation folder.
     * @param storage Presentation storage.
     * @param fontsFolder Fonts folder.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    saveSpecialSlideShape(name, slideIndex, slideType, shapeIndex, format, outPath, options = null, scaleX = null, scaleY = null, bounds = null, password = null, folder = null, storage = null, fontsFolder = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling saveSpecialSlideShape.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling saveSpecialSlideShape.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling saveSpecialSlideShape.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling saveSpecialSlideShape.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling saveSpecialSlideShape.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ShapeExportFormat).filter(i => model.ShapeExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ShapeExportFormat).map(key => model.ShapeExportFormat[key]).join());
            }
            // verify required parameter 'outPath' is not null or undefined
            if (outPath === null || outPath === undefined) {
                throw new Error('The required parameter "outPath" was null or undefined when calling saveSpecialSlideShape.');
            }
            // verify value of enum parameter 'bounds' is valid
            if (bounds != null && bounds != undefined && !Object.keys(model.ShapeThumbnailBounds).filter(i => model.ShapeThumbnailBounds[i].toLowerCase() == bounds.toString().toLowerCase()).length) {
                throw new Error('Invalid value for bounds: ' + bounds + '. Must be one of the following: ' + Object.keys(model.ShapeThumbnailBounds).map(key => model.ShapeThumbnailBounds[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes/{shapeIndex}/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "outPath", outPath);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "scaleX", scaleX);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "scaleY", scaleY);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "bounds", bounds);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: options,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            return Promise.resolve({ response });
        });
    }
    /**
     * Set slide animation.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param animation Animation DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setAnimation(name, slideIndex, animation, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setAnimation.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling setAnimation.');
            }
            // verify required parameter 'animation' is not null or undefined
            if (animation === null || animation === undefined) {
                throw new Error('The required parameter "animation" was null or undefined when calling setAnimation.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/animation";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: animation,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Set background for a slide.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param background Slide background update data.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setBackground(name, slideIndex, background, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setBackground.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling setBackground.');
            }
            // verify required parameter 'background' is not null or undefined
            if (background === null || background === undefined) {
                throw new Error('The required parameter "background" was null or undefined when calling setBackground.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/background";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: background,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideBackground");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Set background color for a slide.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param color Slide background target color in RRGGBB format.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setBackgroundColor(name, slideIndex, color, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setBackgroundColor.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling setBackgroundColor.');
            }
            // verify required parameter 'color' is not null or undefined
            if (color === null || color === undefined) {
                throw new Error('The required parameter "color" was null or undefined when calling setBackgroundColor.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/backgroundColor";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "color", color);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideBackground");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Set chart axis.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param axisType Axis type. Horizontal, Vertical, SecondaryHorizontal or SecondaryVertical.
     * @param axis Axis DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setChartAxis(name, slideIndex, shapeIndex, axisType, axis, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setChartAxis.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling setChartAxis.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling setChartAxis.');
            }
            // verify required parameter 'axisType' is not null or undefined
            if (axisType === null || axisType === undefined) {
                throw new Error('The required parameter "axisType" was null or undefined when calling setChartAxis.');
            }
            // verify value of enum parameter 'axisType' is valid
            if (!Object.keys(model.AxisType).filter(i => model.AxisType[i].toLowerCase() == axisType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for axisType: ' + axisType + '. Must be one of the following: ' + Object.keys(model.AxisType).map(key => model.AxisType[key]).join());
            }
            // verify required parameter 'axis' is not null or undefined
            if (axis === null || axis === undefined) {
                throw new Error('The required parameter "axis" was null or undefined when calling setChartAxis.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/{axisType}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "axisType", objectSerializer_1.ObjectSerializer.toString(axisType));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: axis,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Axis");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Set chart axis.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param legend Chart legend DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setChartLegend(name, slideIndex, shapeIndex, legend, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setChartLegend.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling setChartLegend.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling setChartLegend.');
            }
            // verify required parameter 'legend' is not null or undefined
            if (legend === null || legend === undefined) {
                throw new Error('The required parameter "legend" was null or undefined when calling setChartLegend.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/legend";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: legend,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Legend");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Set a series group in a chart.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index (must be a chart).
     * @param seriesGroupIndex Series group index.
     * @param seriesGroup Series group DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setChartSeriesGroup(name, slideIndex, shapeIndex, seriesGroupIndex, seriesGroup, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setChartSeriesGroup.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling setChartSeriesGroup.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling setChartSeriesGroup.');
            }
            // verify required parameter 'seriesGroupIndex' is not null or undefined
            if (seriesGroupIndex === null || seriesGroupIndex === undefined) {
                throw new Error('The required parameter "seriesGroupIndex" was null or undefined when calling setChartSeriesGroup.');
            }
            // verify required parameter 'seriesGroup' is not null or undefined
            if (seriesGroup === null || seriesGroup === undefined) {
                throw new Error('The required parameter "seriesGroup" was null or undefined when calling setChartSeriesGroup.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/seriesGroup/{seriesGroupIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "seriesGroupIndex", objectSerializer_1.ObjectSerializer.toString(seriesGroupIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: seriesGroup,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Chart");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Set 3D chart wall.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param chartWallType Chart wall type: floor, sideWall or backWall.
     * @param chartWall Chart wall DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setChartWall(name, slideIndex, shapeIndex, chartWallType, chartWall, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setChartWall.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling setChartWall.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling setChartWall.');
            }
            // verify required parameter 'chartWallType' is not null or undefined
            if (chartWallType === null || chartWallType === undefined) {
                throw new Error('The required parameter "chartWallType" was null or undefined when calling setChartWall.');
            }
            // verify value of enum parameter 'chartWallType' is valid
            if (!Object.keys(model.ChartWallType).filter(i => model.ChartWallType[i].toLowerCase() == chartWallType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for chartWallType: ' + chartWallType + '. Must be one of the following: ' + Object.keys(model.ChartWallType).map(key => model.ChartWallType[key]).join());
            }
            // verify required parameter 'chartWall' is not null or undefined
            if (chartWall === null || chartWall === undefined) {
                throw new Error('The required parameter "chartWall" was null or undefined when calling setChartWall.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/{chartWallType}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "chartWallType", objectSerializer_1.ObjectSerializer.toString(chartWallType));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: chartWall,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "ChartWall");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Set document properties.
     * @param name Document name.
     * @param properties New properties.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setDocumentProperties(name, properties, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setDocumentProperties.');
            }
            // verify required parameter 'properties' is not null or undefined
            if (properties === null || properties === undefined) {
                throw new Error('The required parameter "properties" was null or undefined when calling setDocumentProperties.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/documentproperties";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: properties,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "DocumentProperties");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Set document property.
     * @param name Document name.
     * @param propertyName The property name.
     * @param property Property with the value.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setDocumentProperty(name, propertyName, property, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setDocumentProperty.');
            }
            // verify required parameter 'propertyName' is not null or undefined
            if (propertyName === null || propertyName === undefined) {
                throw new Error('The required parameter "propertyName" was null or undefined when calling setDocumentProperty.');
            }
            // verify required parameter 'property' is not null or undefined
            if (property === null || property === undefined) {
                throw new Error('The required parameter "property" was null or undefined when calling setDocumentProperty.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/documentproperties/{propertyName}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "propertyName", objectSerializer_1.ObjectSerializer.toString(propertyName));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: property,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "DocumentProperty");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Embeds specified font and returns presentation fonts info.
     * @param name Document name.
     * @param fontName Font name.
     * @param onlyUsed Only used characters will be embedded.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param fontsFolder Custom fonts folder.
     */
    setEmbeddedFont(name, fontName, onlyUsed = null, password = null, folder = null, storage = null, fontsFolder = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setEmbeddedFont.');
            }
            // verify required parameter 'fontName' is not null or undefined
            if (fontName === null || fontName === undefined) {
                throw new Error('The required parameter "fontName" was null or undefined when calling setEmbeddedFont.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/fonts/embedded/{fontName}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "fontName", objectSerializer_1.ObjectSerializer.toString(fontName));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "onlyUsed", onlyUsed);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "FontsData");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Embeds font from request and returns presentation fonts info.
     * @param font Font data.
     * @param name Document name.
     * @param onlyUsed Only used characters will be embedded.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setEmbeddedFontFromRequest(font, name, onlyUsed = null, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'font' is not null or undefined
            if (font === null || font === undefined) {
                throw new Error('The required parameter "font" was null or undefined when calling setEmbeddedFontFromRequest.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setEmbeddedFontFromRequest.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/fonts/embedded";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "onlyUsed", onlyUsed);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (font != null) {
                localVarFiles.push(font);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "FontsData");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Embeds font from request and returns presentation.
     * @param document Document data.
     * @param font Font data.
     * @param onlyUsed Only used characters will be embedded.
     * @param password Document password.
     */
    setEmbeddedFontFromRequestOnline(document, font, onlyUsed = null, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling setEmbeddedFontFromRequestOnline.');
            }
            // verify required parameter 'font' is not null or undefined
            if (font === null || font === undefined) {
                throw new Error('The required parameter "font" was null or undefined when calling setEmbeddedFontFromRequestOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/fonts/embedded";
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "onlyUsed", onlyUsed);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            if (font != null) {
                localVarFiles.push(font);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Embeds specified font and returns presentation.
     * @param document Document data.
     * @param fontName Font name.
     * @param onlyUsed Only used characters will be embedded.
     * @param password Document password.
     * @param fontsFolder Custom fonts folder.
     */
    setEmbeddedFontOnline(document, fontName, onlyUsed = null, password = null, fontsFolder = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling setEmbeddedFontOnline.');
            }
            // verify required parameter 'fontName' is not null or undefined
            if (fontName === null || fontName === undefined) {
                throw new Error('The required parameter "fontName" was null or undefined when calling setEmbeddedFontOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/fonts/embedded/{fontName}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "fontName", objectSerializer_1.ObjectSerializer.toString(fontName));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "onlyUsed", onlyUsed);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Set header/footer the notes slide.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param dto Header/footer to set.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setNotesSlideHeaderFooter(name, slideIndex, dto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setNotesSlideHeaderFooter.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling setNotesSlideHeaderFooter.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling setNotesSlideHeaderFooter.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/notesSlide/headerFooter";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "NotesSlideHeaderFooter");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Set footers for all slides in a presentation.
     * @param name Document name.
     * @param dto HeaderFooter instance.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setPresentationHeaderFooter(name, dto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setPresentationHeaderFooter.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling setPresentationHeaderFooter.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/headerFooter";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Document");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Updates presentation protection properties.
     * @param name Document name.
     * @param dto Protection properties.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setProtection(name, dto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setProtection.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling setProtection.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/protection";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "ProtectionProperties");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Sets presentation protection options.
     * @param document Document data.
     * @param dto Protection properties.
     * @param password Document password.
     */
    setProtectionOnline(document, dto, password = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling setProtectionOnline.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling setProtectionOnline.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/protection";
            const queryParameters = {};
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Replace existing presentation sections with the ones provided in the sections DTO.
     * @param name Document name.
     * @param sections Sections DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setSections(name, sections, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setSections.');
            }
            // verify required parameter 'sections' is not null or undefined
            if (sections === null || sections === undefined) {
                throw new Error('The required parameter "sections" was null or undefined when calling setSections.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/sections";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: sections,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Sections");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Sets geometry path to the shape
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param dto Geometry paths DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setShapeGeometryPath(name, slideIndex, shapeIndex, dto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setShapeGeometryPath.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling setShapeGeometryPath.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling setShapeGeometryPath.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling setShapeGeometryPath.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/geometryPath";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "ShapeBase");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Set footer the slide.
     * @param name Document name.
     * @param slideIndex The position of the slide to be reordered.
     * @param dto Footer to set.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setSlideHeaderFooter(name, slideIndex, dto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setSlideHeaderFooter.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling setSlideHeaderFooter.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling setSlideHeaderFooter.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/headerFooter";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "HeaderFooter");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update presentation slide properties.
     * @param name Document name.
     * @param dto The view properties data.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setSlideProperties(name, dto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setSlideProperties.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling setSlideProperties.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slideProperties";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideProperties");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update presentation slide show properties.
     * @param name Document name.
     * @param dto The slide show properties data.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setSlideShowProperties(name, dto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setSlideShowProperties.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling setSlideShowProperties.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slideShowProperties";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideShowProperties");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Set special slide (master, layout, notes) animation.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param animation Animation DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setSpecialSlideAnimation(name, slideIndex, slideType, animation, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setSpecialSlideAnimation.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling setSpecialSlideAnimation.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling setSpecialSlideAnimation.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'animation' is not null or undefined
            if (animation === null || animation === undefined) {
                throw new Error('The required parameter "animation" was null or undefined when calling setSpecialSlideAnimation.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/animation";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: animation,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update presentation view properties.
     * @param name Document name.
     * @param dto The view properties data.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    setViewProperties(name, dto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling setViewProperties.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling setViewProperties.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/viewProperties";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "ViewProperties");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Splitting presentations. Create one image per slide.
     * @param name Document name.
     * @param options Export options.
     * @param format Export format. Default value is jpeg.
     * @param width The width of created images.
     * @param height The height of created images.
     * @param from The start slide number for splitting, if is not specified splitting starts from the first slide of the presentation.
     * @param to The last slide number for splitting, if is not specified splitting ends at the last slide of the document.
     * @param destFolder Folder on storage where images are going to be uploaded. If not specified then images are uploaded to same folder as presentation.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param fontsFolder Custom fonts folder.
     */
    split(name, options = null, format = null, width = null, height = null, from = null, to = null, destFolder = null, password = null, folder = null, storage = null, fontsFolder = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling split.');
            }
            // verify value of enum parameter 'format' is valid
            if (format != null && format != undefined && !Object.keys(model.SlideExportFormat).filter(i => model.SlideExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.SlideExportFormat).map(key => model.SlideExportFormat[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/split";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "format", format);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "width", width);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "height", height);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "from", from);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "to", to);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFolder", destFolder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: options,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SplitDocumentResult");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Splits PowerPoint presentation slides from the specified range into separate files and exports them in the specified file format. If the range is not provided all slides will be processed.
     * @param document Document data.
     * @param format ExportFormat
     * @param destFolder Folder on storage where images are going to be uploaded. If not specified then images are uploaded to the root folder.
     * @param width Slide width.
     * @param height Slide height.
     * @param from The start slide number for splitting, if is not specified splitting starts from the first slide of the presentation.
     * @param to The last slide number for splitting, if is not specified splitting ends at the last slide of the document.
     * @param password Document password.
     * @param storage Document storage.
     * @param fontsFolder Custom fonts folder.
     * @param options Export options.
     */
    splitAndSaveOnline(document, format, destFolder = null, width = null, height = null, from = null, to = null, password = null, storage = null, fontsFolder = null, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling splitAndSaveOnline.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling splitAndSaveOnline.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.SlideExportFormat).filter(i => model.SlideExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.SlideExportFormat).map(key => model.SlideExportFormat[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/split/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFolder", destFolder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "width", width);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "height", height);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "from", from);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "to", to);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: options,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SplitDocumentResult");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Splits PowerPoint presentation slides from the specified range into separate files and exports them in the specified file format. If the range is not provided all slides will be processed.
     * @param document Document data.
     * @param format ExportFormat
     * @param width Slide width.
     * @param height Slide height.
     * @param from The start slide number for splitting, if is not specified splitting starts from the first slide of the presentation.
     * @param to The last slide number for splitting, if is not specified splitting ends at the last slide of the document.
     * @param password Document password.
     * @param storage Document storage.
     * @param fontsFolder Custom fonts folder.
     * @param options Export options.
     */
    splitOnline(document, format, width = null, height = null, from = null, to = null, password = null, storage = null, fontsFolder = null, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling splitOnline.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling splitOnline.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.SlideExportFormat).filter(i => model.SlideExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.SlideExportFormat).map(key => model.SlideExportFormat[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/split/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "width", width);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "height", height);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "from", from);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "to", to);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: options,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Split table cell.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param rowIndex Row index.
     * @param cellIndex Table cell index.
     * @param splitType Table cell split type (SplitByWidth, SplitByHeight,SplitByColSpan or SplitByRowSpan).
     * @param value Split value. In case of splitting by column or row span, the value must be an integer number.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    splitTableCell(name, slideIndex, shapeIndex, rowIndex, cellIndex, splitType, value, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling splitTableCell.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling splitTableCell.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling splitTableCell.');
            }
            // verify required parameter 'rowIndex' is not null or undefined
            if (rowIndex === null || rowIndex === undefined) {
                throw new Error('The required parameter "rowIndex" was null or undefined when calling splitTableCell.');
            }
            // verify required parameter 'cellIndex' is not null or undefined
            if (cellIndex === null || cellIndex === undefined) {
                throw new Error('The required parameter "cellIndex" was null or undefined when calling splitTableCell.');
            }
            // verify required parameter 'splitType' is not null or undefined
            if (splitType === null || splitType === undefined) {
                throw new Error('The required parameter "splitType" was null or undefined when calling splitTableCell.');
            }
            // verify value of enum parameter 'splitType' is valid
            if (!Object.keys(model.TableCellSplitType).filter(i => model.TableCellSplitType[i].toLowerCase() == splitType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for splitType: ' + splitType + '. Must be one of the following: ' + Object.keys(model.TableCellSplitType).map(key => model.TableCellSplitType[key]).join());
            }
            // verify required parameter 'value' is not null or undefined
            if (value === null || value === undefined) {
                throw new Error('The required parameter "value" was null or undefined when calling splitTableCell.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/rows/{rowIndex}/cells/{cellIndex}/{splitType}/{value}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "rowIndex", objectSerializer_1.ObjectSerializer.toString(rowIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "cellIndex", objectSerializer_1.ObjectSerializer.toString(cellIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "splitType", objectSerializer_1.ObjectSerializer.toString(splitType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "value", objectSerializer_1.ObjectSerializer.toString(value));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Table");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Check if storage exists
     * @param storageName Storage name
     */
    storageExists(storageName) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'storageName' is not null or undefined
            if (storageName === null || storageName === undefined) {
                throw new Error('The required parameter "storageName" was null or undefined when calling storageExists.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/storage/{storageName}/exist";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "storageName", objectSerializer_1.ObjectSerializer.toString(storageName));
            const queryParameters = {};
            const requestOptions = {
                method: "GET",
                url: localVarPath,
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "StorageExist");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Modify an animation effect for a slide.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param effectIndex The position of the effect to be modified.
     * @param effect Animation effect DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    updateAnimationEffect(name, slideIndex, effectIndex, effect, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateAnimationEffect.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateAnimationEffect.');
            }
            // verify required parameter 'effectIndex' is not null or undefined
            if (effectIndex === null || effectIndex === undefined) {
                throw new Error('The required parameter "effectIndex" was null or undefined when calling updateAnimationEffect.');
            }
            // verify required parameter 'effect' is not null or undefined
            if (effect === null || effect === undefined) {
                throw new Error('The required parameter "effect" was null or undefined when calling updateAnimationEffect.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/animation/mainSequence/{effectIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "effectIndex", objectSerializer_1.ObjectSerializer.toString(effectIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: effect,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Modify an animation effect for a slide interactive sequence.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param sequenceIndex The position of the interactive sequence.
     * @param effectIndex The position of the effect to be modified.
     * @param effect Animation effect DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    updateAnimationInteractiveSequenceEffect(name, slideIndex, sequenceIndex, effectIndex, effect, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'sequenceIndex' is not null or undefined
            if (sequenceIndex === null || sequenceIndex === undefined) {
                throw new Error('The required parameter "sequenceIndex" was null or undefined when calling updateAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'effectIndex' is not null or undefined
            if (effectIndex === null || effectIndex === undefined) {
                throw new Error('The required parameter "effectIndex" was null or undefined when calling updateAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'effect' is not null or undefined
            if (effect === null || effect === undefined) {
                throw new Error('The required parameter "effect" was null or undefined when calling updateAnimationInteractiveSequenceEffect.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/animation/interactiveSequences/{sequenceIndex}/{effectIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "sequenceIndex", objectSerializer_1.ObjectSerializer.toString(sequenceIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "effectIndex", objectSerializer_1.ObjectSerializer.toString(effectIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: effect,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update a chart category.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param categoryIndex Category index.
     * @param category Category DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    updateChartCategory(name, slideIndex, shapeIndex, categoryIndex, category, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateChartCategory.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateChartCategory.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling updateChartCategory.');
            }
            // verify required parameter 'categoryIndex' is not null or undefined
            if (categoryIndex === null || categoryIndex === undefined) {
                throw new Error('The required parameter "categoryIndex" was null or undefined when calling updateChartCategory.');
            }
            // verify required parameter 'category' is not null or undefined
            if (category === null || category === undefined) {
                throw new Error('The required parameter "category" was null or undefined when calling updateChartCategory.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/categories/{categoryIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "categoryIndex", objectSerializer_1.ObjectSerializer.toString(categoryIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: category,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Chart");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update a data point in a chart series.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param seriesIndex Series index.
     * @param pointIndex Data point index.
     * @param dataPoint Data point DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    updateChartDataPoint(name, slideIndex, shapeIndex, seriesIndex, pointIndex, dataPoint, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateChartDataPoint.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateChartDataPoint.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling updateChartDataPoint.');
            }
            // verify required parameter 'seriesIndex' is not null or undefined
            if (seriesIndex === null || seriesIndex === undefined) {
                throw new Error('The required parameter "seriesIndex" was null or undefined when calling updateChartDataPoint.');
            }
            // verify required parameter 'pointIndex' is not null or undefined
            if (pointIndex === null || pointIndex === undefined) {
                throw new Error('The required parameter "pointIndex" was null or undefined when calling updateChartDataPoint.');
            }
            // verify required parameter 'dataPoint' is not null or undefined
            if (dataPoint === null || dataPoint === undefined) {
                throw new Error('The required parameter "dataPoint" was null or undefined when calling updateChartDataPoint.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/series/{seriesIndex}/dataPoints/{pointIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "seriesIndex", objectSerializer_1.ObjectSerializer.toString(seriesIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "pointIndex", objectSerializer_1.ObjectSerializer.toString(pointIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dataPoint,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Chart");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update a series in a chart.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index (must be a chart).
     * @param seriesIndex Series index.
     * @param series Series DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    updateChartSeries(name, slideIndex, shapeIndex, seriesIndex, series, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateChartSeries.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateChartSeries.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling updateChartSeries.');
            }
            // verify required parameter 'seriesIndex' is not null or undefined
            if (seriesIndex === null || seriesIndex === undefined) {
                throw new Error('The required parameter "seriesIndex" was null or undefined when calling updateChartSeries.');
            }
            // verify required parameter 'series' is not null or undefined
            if (series === null || series === undefined) {
                throw new Error('The required parameter "series" was null or undefined when calling updateChartSeries.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/series/{seriesIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "seriesIndex", objectSerializer_1.ObjectSerializer.toString(seriesIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: series,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Chart");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update a layoutSlide.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param slideDto Slide update data.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    updateLayoutSlide(name, slideIndex, slideDto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateLayoutSlide.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateLayoutSlide.');
            }
            // verify required parameter 'slideDto' is not null or undefined
            if (slideDto === null || slideDto === undefined) {
                throw new Error('The required parameter "slideDto" was null or undefined when calling updateLayoutSlide.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/layoutSlides/{slideIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: slideDto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "LayoutSlide");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update notes slide properties.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param dto A NotesSlide object with notes slide data.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    updateNotesSlide(name, slideIndex, dto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateNotesSlide.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateNotesSlide.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling updateNotesSlide.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/notesSlide";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "NotesSlide");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update paragraph properties.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param dto Paragraph DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    updateParagraph(name, slideIndex, shapeIndex, paragraphIndex, dto, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateParagraph.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateParagraph.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling updateParagraph.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling updateParagraph.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling updateParagraph.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Paragraph");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update portion properties.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param portionIndex Portion index.
     * @param dto Portion DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    updatePortion(name, slideIndex, shapeIndex, paragraphIndex, portionIndex, dto, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updatePortion.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updatePortion.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling updatePortion.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling updatePortion.');
            }
            // verify required parameter 'portionIndex' is not null or undefined
            if (portionIndex === null || portionIndex === undefined) {
                throw new Error('The required parameter "portionIndex" was null or undefined when calling updatePortion.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling updatePortion.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}/portions/{portionIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "portionIndex", objectSerializer_1.ObjectSerializer.toString(portionIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Portion");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update section name.
     * @param name Document name.
     * @param sectionIndex The position of the section to be updated.
     * @param sectionName Section name.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    updateSection(name, sectionIndex, sectionName, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateSection.');
            }
            // verify required parameter 'sectionIndex' is not null or undefined
            if (sectionIndex === null || sectionIndex === undefined) {
                throw new Error('The required parameter "sectionIndex" was null or undefined when calling updateSection.');
            }
            // verify required parameter 'sectionName' is not null or undefined
            if (sectionName === null || sectionName === undefined) {
                throw new Error('The required parameter "sectionName" was null or undefined when calling updateSection.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/sections/{sectionIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "sectionIndex", objectSerializer_1.ObjectSerializer.toString(sectionIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "sectionName", sectionName);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Sections");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update shape properties.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param dto Shape DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    updateShape(name, slideIndex, shapeIndex, dto, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateShape.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateShape.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling updateShape.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling updateShape.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "ShapeBase");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update a slide.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param slideDto Slide update data.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    updateSlide(name, slideIndex, slideDto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateSlide.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateSlide.');
            }
            // verify required parameter 'slideDto' is not null or undefined
            if (slideDto === null || slideDto === undefined) {
                throw new Error('The required parameter "slideDto" was null or undefined when calling updateSlide.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: slideDto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Slide");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Modify an animation effect for a special slide (master, layout, notes).
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param effectIndex The position of the effect to be modified.
     * @param effect Animation effect DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    updateSpecialSlideAnimationEffect(name, slideIndex, slideType, effectIndex, effect, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateSpecialSlideAnimationEffect.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateSpecialSlideAnimationEffect.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling updateSpecialSlideAnimationEffect.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'effectIndex' is not null or undefined
            if (effectIndex === null || effectIndex === undefined) {
                throw new Error('The required parameter "effectIndex" was null or undefined when calling updateSpecialSlideAnimationEffect.');
            }
            // verify required parameter 'effect' is not null or undefined
            if (effect === null || effect === undefined) {
                throw new Error('The required parameter "effect" was null or undefined when calling updateSpecialSlideAnimationEffect.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/animation/mainSequence/{effectIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "effectIndex", objectSerializer_1.ObjectSerializer.toString(effectIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: effect,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Modify an animation effect for a special slide (master, layout, notes) interactive sequence.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param sequenceIndex The position of the interactive sequence.
     * @param effectIndex The position of the effect to be modified.
     * @param effect Animation effect DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    updateSpecialSlideAnimationInteractiveSequenceEffect(name, slideIndex, slideType, sequenceIndex, effectIndex, effect, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateSpecialSlideAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateSpecialSlideAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling updateSpecialSlideAnimationInteractiveSequenceEffect.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'sequenceIndex' is not null or undefined
            if (sequenceIndex === null || sequenceIndex === undefined) {
                throw new Error('The required parameter "sequenceIndex" was null or undefined when calling updateSpecialSlideAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'effectIndex' is not null or undefined
            if (effectIndex === null || effectIndex === undefined) {
                throw new Error('The required parameter "effectIndex" was null or undefined when calling updateSpecialSlideAnimationInteractiveSequenceEffect.');
            }
            // verify required parameter 'effect' is not null or undefined
            if (effect === null || effect === undefined) {
                throw new Error('The required parameter "effect" was null or undefined when calling updateSpecialSlideAnimationInteractiveSequenceEffect.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/animation/interactiveSequences/{sequenceIndex}/{effectIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "sequenceIndex", objectSerializer_1.ObjectSerializer.toString(sequenceIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "effectIndex", objectSerializer_1.ObjectSerializer.toString(effectIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: effect,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "SlideAnimation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update paragraph properties.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param dto Paragraph DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    updateSpecialSlideParagraph(name, slideIndex, slideType, shapeIndex, paragraphIndex, dto, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateSpecialSlideParagraph.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateSpecialSlideParagraph.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling updateSpecialSlideParagraph.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling updateSpecialSlideParagraph.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling updateSpecialSlideParagraph.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling updateSpecialSlideParagraph.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Paragraph");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update portion properties.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapeIndex Shape index.
     * @param paragraphIndex Paragraph index.
     * @param portionIndex Portion index.
     * @param dto Portion DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    updateSpecialSlidePortion(name, slideIndex, slideType, shapeIndex, paragraphIndex, portionIndex, dto, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateSpecialSlidePortion.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateSpecialSlidePortion.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling updateSpecialSlidePortion.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling updateSpecialSlidePortion.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling updateSpecialSlidePortion.');
            }
            // verify required parameter 'portionIndex' is not null or undefined
            if (portionIndex === null || portionIndex === undefined) {
                throw new Error('The required parameter "portionIndex" was null or undefined when calling updateSpecialSlidePortion.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling updateSpecialSlidePortion.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes/{shapeIndex}/paragraphs/{paragraphIndex}/portions/{portionIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "portionIndex", objectSerializer_1.ObjectSerializer.toString(portionIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Portion");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update shape properties.
     * @param name Document name.
     * @param slideIndex Parent slide index.
     * @param slideType Slide type (master, layout or notes).
     * @param shapeIndex Shape index.
     * @param dto Shape DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     * @param subShape Sub-shape path (e.g. \"3\", \"3/shapes/2).
     */
    updateSpecialSlideShape(name, slideIndex, slideType, shapeIndex, dto, password = null, folder = null, storage = null, subShape = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateSpecialSlideShape.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateSpecialSlideShape.');
            }
            // verify required parameter 'slideType' is not null or undefined
            if (slideType === null || slideType === undefined) {
                throw new Error('The required parameter "slideType" was null or undefined when calling updateSpecialSlideShape.');
            }
            // verify value of enum parameter 'slideType' is valid
            if (!Object.keys(model.SpecialSlideType).filter(i => model.SpecialSlideType[i].toLowerCase() == slideType.toString().toLowerCase()).length) {
                throw new Error('Invalid value for slideType: ' + slideType + '. Must be one of the following: ' + Object.keys(model.SpecialSlideType).map(key => model.SpecialSlideType[key]).join());
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling updateSpecialSlideShape.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling updateSpecialSlideShape.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/{slideType}/shapes/{shapeIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideType", objectSerializer_1.ObjectSerializer.toString(slideType));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "subShape", subShape);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "ShapeBase");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update the table cell.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param rowIndex Row index.
     * @param cellIndex Table cell index.
     * @param dto Table cell data.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    updateTableCell(name, slideIndex, shapeIndex, rowIndex, cellIndex, dto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateTableCell.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateTableCell.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling updateTableCell.');
            }
            // verify required parameter 'rowIndex' is not null or undefined
            if (rowIndex === null || rowIndex === undefined) {
                throw new Error('The required parameter "rowIndex" was null or undefined when calling updateTableCell.');
            }
            // verify required parameter 'cellIndex' is not null or undefined
            if (cellIndex === null || cellIndex === undefined) {
                throw new Error('The required parameter "cellIndex" was null or undefined when calling updateTableCell.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling updateTableCell.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/rows/{rowIndex}/cells/{cellIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "rowIndex", objectSerializer_1.ObjectSerializer.toString(rowIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "cellIndex", objectSerializer_1.ObjectSerializer.toString(cellIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "TableCell");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Updates table cell paragraph.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param rowIndex Row index.
     * @param cellIndex Table cell index.
     * @param paragraphIndex Paragraph index.
     * @param dto Paragraph DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    updateTableCellParagraph(name, slideIndex, shapeIndex, rowIndex, cellIndex, paragraphIndex, dto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateTableCellParagraph.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateTableCellParagraph.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling updateTableCellParagraph.');
            }
            // verify required parameter 'rowIndex' is not null or undefined
            if (rowIndex === null || rowIndex === undefined) {
                throw new Error('The required parameter "rowIndex" was null or undefined when calling updateTableCellParagraph.');
            }
            // verify required parameter 'cellIndex' is not null or undefined
            if (cellIndex === null || cellIndex === undefined) {
                throw new Error('The required parameter "cellIndex" was null or undefined when calling updateTableCellParagraph.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling updateTableCellParagraph.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling updateTableCellParagraph.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/rows/{rowIndex}/cells/{cellIndex}/paragraphs/{paragraphIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "rowIndex", objectSerializer_1.ObjectSerializer.toString(rowIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "cellIndex", objectSerializer_1.ObjectSerializer.toString(cellIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Paragraph");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Updates table cell portion.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param rowIndex Row index.
     * @param cellIndex Table cell index.
     * @param paragraphIndex Paragraph index.
     * @param portionIndex Portion index.
     * @param dto Portion DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    updateTableCellPortion(name, slideIndex, shapeIndex, rowIndex, cellIndex, paragraphIndex, portionIndex, dto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateTableCellPortion.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateTableCellPortion.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling updateTableCellPortion.');
            }
            // verify required parameter 'rowIndex' is not null or undefined
            if (rowIndex === null || rowIndex === undefined) {
                throw new Error('The required parameter "rowIndex" was null or undefined when calling updateTableCellPortion.');
            }
            // verify required parameter 'cellIndex' is not null or undefined
            if (cellIndex === null || cellIndex === undefined) {
                throw new Error('The required parameter "cellIndex" was null or undefined when calling updateTableCellPortion.');
            }
            // verify required parameter 'paragraphIndex' is not null or undefined
            if (paragraphIndex === null || paragraphIndex === undefined) {
                throw new Error('The required parameter "paragraphIndex" was null or undefined when calling updateTableCellPortion.');
            }
            // verify required parameter 'portionIndex' is not null or undefined
            if (portionIndex === null || portionIndex === undefined) {
                throw new Error('The required parameter "portionIndex" was null or undefined when calling updateTableCellPortion.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling updateTableCellPortion.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/rows/{rowIndex}/cells/{cellIndex}/paragraphs/{paragraphIndex}/portions/{portionIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "rowIndex", objectSerializer_1.ObjectSerializer.toString(rowIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "cellIndex", objectSerializer_1.ObjectSerializer.toString(cellIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "paragraphIndex", objectSerializer_1.ObjectSerializer.toString(paragraphIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "portionIndex", objectSerializer_1.ObjectSerializer.toString(portionIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Portion");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update the table row.
     * @param name Document name.
     * @param slideIndex Slide index.
     * @param shapeIndex Shape index.
     * @param rowIndex Row index.
     * @param dto Table cell data.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    updateTableRow(name, slideIndex, shapeIndex, rowIndex, dto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateTableRow.');
            }
            // verify required parameter 'slideIndex' is not null or undefined
            if (slideIndex === null || slideIndex === undefined) {
                throw new Error('The required parameter "slideIndex" was null or undefined when calling updateTableRow.');
            }
            // verify required parameter 'shapeIndex' is not null or undefined
            if (shapeIndex === null || shapeIndex === undefined) {
                throw new Error('The required parameter "shapeIndex" was null or undefined when calling updateTableRow.');
            }
            // verify required parameter 'rowIndex' is not null or undefined
            if (rowIndex === null || rowIndex === undefined) {
                throw new Error('The required parameter "rowIndex" was null or undefined when calling updateTableRow.');
            }
            // verify required parameter 'dto' is not null or undefined
            if (dto === null || dto === undefined) {
                throw new Error('The required parameter "dto" was null or undefined when calling updateTableRow.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/slides/{slideIndex}/shapes/{shapeIndex}/rows/{rowIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "slideIndex", objectSerializer_1.ObjectSerializer.toString(slideIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "shapeIndex", objectSerializer_1.ObjectSerializer.toString(shapeIndex));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "rowIndex", objectSerializer_1.ObjectSerializer.toString(rowIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: dto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "TableRow");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Update VBA module.
     * @param name Document name.
     * @param moduleIndex The index of the macros module to remove.
     * @param moduleDto VBA module DTO.
     * @param password Document password.
     * @param folder Document folder.
     * @param storage Document storage.
     */
    updateVbaModule(name, moduleIndex, moduleDto, password = null, folder = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling updateVbaModule.');
            }
            // verify required parameter 'moduleIndex' is not null or undefined
            if (moduleIndex === null || moduleIndex === undefined) {
                throw new Error('The required parameter "moduleIndex" was null or undefined when calling updateVbaModule.');
            }
            // verify required parameter 'moduleDto' is not null or undefined
            if (moduleDto === null || moduleDto === undefined) {
                throw new Error('The required parameter "moduleDto" was null or undefined when calling updateVbaModule.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/{name}/vbaProject/modules/{moduleIndex}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "moduleIndex", objectSerializer_1.ObjectSerializer.toString(moduleIndex));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: moduleDto,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "VbaModule");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     * Upload file
     * @param path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext             If the content is multipart and path does not contains the file name it tries to get them from filename parameter             from Content-Disposition header.
     * @param file File to upload
     * @param storageName Storage name
     */
    uploadFile(path = null, file, storageName = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new Error('The required parameter "file" was null or undefined when calling uploadFile.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/storage/file/{path}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "path", objectSerializer_1.ObjectSerializer.toString(path));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storageName", storageName);
            const requestOptions = {
                method: "PUT",
                url: localVarPath,
                params: queryParameters
            };
            let localVarFiles = [];
            if (file != null) {
                localVarFiles.push(file);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "FilesUploadResult");
            return Promise.resolve({ body: result, response });
        });
    }
}
exports.SlidesApi = SlidesApi;
class SlidesAsyncApi {
    get configuration() {
        return this._configuration;
    }
    /**
     * @param appSid Client Id.
     * @param appKey Client Secret.
     * @param baseUrl Base api Url.
     * @param authBaseUrl Base authentication Url.
     * @param debugMode A value indicating whether debug mode. In debug mode all requests and responses are logged to console.
     * @param timeout Timeout (in seconds) for an operation. Applies to the Slides operation, not to the HTTP request.
     */
    constructor(appSid, appKey, baseUrl, authBaseUrl, debugMode, timeout) {
        this._configuration = new configuration_1.Configuration(appSid, appKey, baseUrl, authBaseUrl, debugMode, timeout);
    }
    /**
     *
     * @param id
     */
    getOperationResult(id) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new Error('The required parameter "id" was null or undefined when calling getOperationResult.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/async/{id}/result";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "id", objectSerializer_1.ObjectSerializer.toString(id));
            const queryParameters = {};
            const requestOptions = {
                method: "GET",
                url: localVarPath,
                responseType: 'arraybuffer',
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Buffer");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     *
     * @param id
     */
    getOperationStatus(id) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new Error('The required parameter "id" was null or undefined when calling getOperationStatus.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/async/{id}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "id", objectSerializer_1.ObjectSerializer.toString(id));
            const queryParameters = {};
            const requestOptions = {
                method: "GET",
                url: localVarPath,
                params: queryParameters
            };
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "Operation");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     *
     * @param document Document data.
     * @param format
     * @param password
     * @param storage
     * @param fontsFolder
     * @param slides
     * @param options
     */
    startConvert(document, format, password = null, storage = null, fontsFolder = null, slides = null, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling startConvert.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling startConvert.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ExportFormat).filter(i => model.ExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ExportFormat).map(key => model.ExportFormat[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/async/convert/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "slides", slides);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: options,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "string");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     *
     * @param document Document data.
     * @param format
     * @param outPath
     * @param password
     * @param storage
     * @param fontsFolder
     * @param slides
     * @param options
     */
    startConvertAndSave(document, format, outPath, password = null, storage = null, fontsFolder = null, slides = null, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling startConvertAndSave.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling startConvertAndSave.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ExportFormat).filter(i => model.ExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ExportFormat).map(key => model.ExportFormat[key]).join());
            }
            // verify required parameter 'outPath' is not null or undefined
            if (outPath === null || outPath === undefined) {
                throw new Error('The required parameter "outPath" was null or undefined when calling startConvertAndSave.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/async/convert/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "outPath", outPath);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "slides", slides);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: options,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "string");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     *
     * @param name
     * @param format
     * @param options
     * @param password
     * @param folder
     * @param storage
     * @param fontsFolder
     * @param slides
     */
    startDownloadPresentation(name, format, options = null, password = null, folder = null, storage = null, fontsFolder = null, slides = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling startDownloadPresentation.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling startDownloadPresentation.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ExportFormat).filter(i => model.ExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ExportFormat).map(key => model.ExportFormat[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/async/{name}/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "slides", slides);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: options,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "string");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     *
     * @param files Files to merge
     * @param request
     * @param storage
     */
    startMerge(files = null, request = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/async/merge";
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "POST",
                url: localVarPath,
                data: request,
                params: queryParameters
            };
            let localVarFiles = [];
            if (files != null) {
                localVarFiles = localVarFiles.concat(files);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "string");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     *
     * @param outPath
     * @param files Files to merge
     * @param request
     * @param storage
     */
    startMergeAndSave(outPath, files = null, request = null, storage = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'outPath' is not null or undefined
            if (outPath === null || outPath === undefined) {
                throw new Error('The required parameter "outPath" was null or undefined when calling startMergeAndSave.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/async/merge";
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "outPath", outPath);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            const requestOptions = {
                method: "PUT",
                url: localVarPath,
                data: request,
                params: queryParameters
            };
            let localVarFiles = [];
            if (files != null) {
                localVarFiles = localVarFiles.concat(files);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "string");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     *
     * @param name
     * @param format
     * @param outPath
     * @param options
     * @param password
     * @param folder
     * @param storage
     * @param fontsFolder
     * @param slides
     */
    startSavePresentation(name, format, outPath, options = null, password = null, folder = null, storage = null, fontsFolder = null, slides = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling startSavePresentation.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling startSavePresentation.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.ExportFormat).filter(i => model.ExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.ExportFormat).map(key => model.ExportFormat[key]).join());
            }
            // verify required parameter 'outPath' is not null or undefined
            if (outPath === null || outPath === undefined) {
                throw new Error('The required parameter "outPath" was null or undefined when calling startSavePresentation.');
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/async/{name}/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "outPath", outPath);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "slides", slides);
            const requestOptions = {
                method: "PUT",
                headers: {},
                url: localVarPath,
                data: options,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "string");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     *
     * @param name
     * @param format
     * @param options
     * @param width
     * @param height
     * @param from
     * @param to
     * @param destFolder
     * @param password
     * @param folder
     * @param storage
     * @param fontsFolder
     */
    startSplit(name, format, options = null, width = null, height = null, from = null, to = null, destFolder = null, password = null, folder = null, storage = null, fontsFolder = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new Error('The required parameter "name" was null or undefined when calling startSplit.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling startSplit.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.SlideExportFormat).filter(i => model.SlideExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.SlideExportFormat).map(key => model.SlideExportFormat[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/async/{name}/split/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "name", objectSerializer_1.ObjectSerializer.toString(name));
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "width", width);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "height", height);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "from", from);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "to", to);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFolder", destFolder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", folder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: options,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "string");
            return Promise.resolve({ body: result, response });
        });
    }
    /**
     *
     * @param document Document data.
     * @param format
     * @param destFolder
     * @param width
     * @param height
     * @param from
     * @param to
     * @param password
     * @param storage
     * @param fontsFolder
     * @param options
     */
    startUploadAndSplit(document, format, destFolder = null, width = null, height = null, from = null, to = null, password = null, storage = null, fontsFolder = null, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'document' is not null or undefined
            if (document === null || document === undefined) {
                throw new Error('The required parameter "document" was null or undefined when calling startUploadAndSplit.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new Error('The required parameter "format" was null or undefined when calling startUploadAndSplit.');
            }
            // verify value of enum parameter 'format' is valid
            if (!Object.keys(model.SlideExportFormat).filter(i => model.SlideExportFormat[i].toLowerCase() == format.toString().toLowerCase()).length) {
                throw new Error('Invalid value for format: ' + format + '. Must be one of the following: ' + Object.keys(model.SlideExportFormat).map(key => model.SlideExportFormat[key]).join());
            }
            let localVarPath = this.configuration.getApiBaseUrl() + "/slides/async/split/{format}";
            localVarPath = (0, requestHelper_1.addPathParameterToUrl)(localVarPath, "format", objectSerializer_1.ObjectSerializer.toString(format));
            const queryParameters = {};
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFolder", destFolder);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "width", width);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "height", height);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "from", from);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "to", to);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", storage);
            localVarPath = (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsFolder", fontsFolder);
            const requestOptions = {
                method: "POST",
                headers: {},
                url: localVarPath,
                data: options,
                params: queryParameters
            };
            (0, requestHelper_1.addHeaderParameter)(requestOptions.headers, "password", password);
            let localVarFiles = [];
            if (document != null) {
                localVarFiles.push(document);
            }
            (0, requestHelper_1.checkMultipartContent)(requestOptions, localVarFiles);
            const response = yield (0, requestHelper_1.invokeApiMethod)(requestOptions, this.configuration);
            const result = objectSerializer_1.ObjectSerializer.deserialize(response.body, "string");
            return Promise.resolve({ body: result, response });
        });
    }
}
exports.SlidesAsyncApi = SlidesAsyncApi;
